<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.467">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Métodos Numéricos con Python - 1&nbsp; Conceptos básicos de análisis numérico</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./index.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01_intro.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Conceptos básicos de análisis numérico</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Métodos Numéricos con Python</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/mpru/metodos_numericos/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Métodos-Numéricos-con-Python.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Conceptos básicos de análisis numérico</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#errores-de-truncamiento-de-redondeo-y-aritmética-computacional" id="toc-errores-de-truncamiento-de-redondeo-y-aritmética-computacional" class="nav-link active" data-scroll-target="#errores-de-truncamiento-de-redondeo-y-aritmética-computacional"><span class="header-section-number">1.1</span> Errores de truncamiento, de redondeo y aritmética computacional</a></li>
  <li><a href="#sistemas-de-numeración" id="toc-sistemas-de-numeración" class="nav-link" data-scroll-target="#sistemas-de-numeración"><span class="header-section-number">1.2</span> Sistemas de numeración</a>
  <ul class="collapse">
  <li><a href="#el-sistema-decimal" id="toc-el-sistema-decimal" class="nav-link" data-scroll-target="#el-sistema-decimal"><span class="header-section-number">1.2.1</span> El sistema decimal</a></li>
  <li><a href="#el-sistema-binario" id="toc-el-sistema-binario" class="nav-link" data-scroll-target="#el-sistema-binario"><span class="header-section-number">1.2.2</span> El sistema binario</a></li>
  <li><a href="#conversión-de-decimal-a-binario" id="toc-conversión-de-decimal-a-binario" class="nav-link" data-scroll-target="#conversión-de-decimal-a-binario"><span class="header-section-number">1.2.3</span> Conversión de decimal a binario</a></li>
  <li><a href="#por-qué-nos-interesa-el-sistema-binario" id="toc-por-qué-nos-interesa-el-sistema-binario" class="nav-link" data-scroll-target="#por-qué-nos-interesa-el-sistema-binario"><span class="header-section-number">1.2.4</span> ¿Por qué nos interesa el sistema binario?</a></li>
  </ul></li>
  <li><a href="#números-de-máquina-binarios" id="toc-números-de-máquina-binarios" class="nav-link" data-scroll-target="#números-de-máquina-binarios"><span class="header-section-number">1.3</span> Números de máquina binarios</a></li>
  <li><a href="#poda-redondeo-y-medida-del-error" id="toc-poda-redondeo-y-medida-del-error" class="nav-link" data-scroll-target="#poda-redondeo-y-medida-del-error"><span class="header-section-number">1.4</span> Poda, redondeo y medida del error</a></li>
  <li><a href="#aritmética-de-dígitos-finitos" id="toc-aritmética-de-dígitos-finitos" class="nav-link" data-scroll-target="#aritmética-de-dígitos-finitos"><span class="header-section-number">1.5</span> Aritmética de dígitos finitos</a></li>
  <li><a href="#estabilidad-de-los-algoritmos" id="toc-estabilidad-de-los-algoritmos" class="nav-link" data-scroll-target="#estabilidad-de-los-algoritmos"><span class="header-section-number">1.6</span> Estabilidad de los algoritmos</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/mpru/metodos_numericos/edit/main/01_intro.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mpru/metodos_numericos/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mpru/metodos_numericos/blob/main/01_intro.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Conceptos básicos de análisis numérico</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="errores-de-truncamiento-de-redondeo-y-aritmética-computacional" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="errores-de-truncamiento-de-redondeo-y-aritmética-computacional"><span class="header-section-number">1.1</span> Errores de truncamiento, de redondeo y aritmética computacional</h2>
<ul>
<li><p>Como ya hemos dicho, un método numérico propone un algoritmo para resolver de forma aproximada un problema que no se puede resolver mediante métodos analíticos.</p></li>
<li><p>Esto hace que inevitablemente haya errores en las soluciones obtenidas.</p></li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: se llama <strong>error de truncamiento</strong> a la diferencia entre el valor aproximado propuesto por el método y la solución exacta del problema.</p>
</div>
<ul>
<li><p>Este tipo de error ocurre cuando un proceso que requiere un número infinito de pasos debe ser detenido en una cantidad finita de iteraciones.</p></li>
<li><p>Por ejemplo, podemos recordar el desarrollo en serie de Taylor de la función <span class="math inline">\(f(x) = e^{x^2}\)</span> alrededor del cero:</p>
<p><span class="math display">\[e^{x^2} = 1 + x^2 + \frac{x^4}{2!} + \frac{x^6}{3!} + ... + \frac{x^{2n}}{n!} + ...\]</span></p></li>
<li><p>Si nos quedamos sólo con los primeros 4 términos, estamos aproximando una suma que tiene una infinita cantidad de sumandos sólo con los primeros 4, de manera que dicha aproximación presentará un error de truncamiento.</p></li>
<li><p>Mientras que el valor exacto de <span class="math inline">\(f(0.5) = e^{0.5^2}\)</span> es <span class="math inline">\(1.2840\)</span>, la aproximación de Taylor con 4 términos da <span class="math inline">\(1.2839\)</span>. Esta diferencia es un <em>error de truncamiento</em>.</p></li>
<li><p>Sin embargo, al realizar cálculos con una máquina se presenta otro tipo de errores que generalmente ignoramos.</p></li>
<li><p>Esto pasa porque la aritmética realizada con una calculadora o computadora es diferente a la que hacemos “mentalmente”.</p></li>
<li><p>Ejemplo: sabemos que <span class="math inline">\((\sqrt3)^2 = 3\)</span>. Pero… ¿qué pasa si corremos en Python lo siguiente?</p></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>sqrt(<span class="dv">3</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; False</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><p>En nuestro mundo matemático tradicional, los números pueden tener una infinita cantidad de dígitos. Por eso podemos operar con números como <span class="math inline">\(\sqrt3\)</span>, que es irracional.</p></li>
<li><p>¿Pero una computadora? ¿Puede trabajar con infinitos dígitos?</p></li>
<li><p>En el mundo computacional cada número tiene una cantidad fija y finita de dígitos. Sólo los números racionales (y no todos) pueden ser representados de forma exacta por la computadora.</p></li>
<li><p>Entonces, la máquina trabaja con una representación aproximada de <span class="math inline">\(\sqrt3\)</span> que no es exactamente igual a ese valor. Sin embargo, esa aproximación a <span class="math inline">\(\sqrt3\)</span> que hace la compu explica el resultado de <code>sqrt(3)**2 == 3</code>.</p></li>
<li><p>En muchos casos esa aproximación es aceptable y no le damos importancia a la diferencia que tiene con respecto al valor exacto. En otros casos, esto puede generar problemas.</p></li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: se llama <strong>error de redondeo</strong> al error que se produce cuando se utiliza una computadora para realizar cálculos con números reales, debido a que la aritmética realizada en una máquina incluye números con una cantidad finita de dígitos, dando como resultado cálculos realizados con representaciones aproximadas de los números reales.</p>
</div>
<ul>
<li><p>El error de redondeo está ligado fundamentalmente al tipo de precisión que se emplee (determinado por el procesador y software usados). Sin embargo, el efecto final de los errores de redondeo depende también del algoritmo propuesto para aplicar un método numérico y de la forma de programarlo.</p></li>
<li><p>Existen operaciones que son especialmente sensibles a los errores de redondeo o también puede ser que un algoritmo haga que los mismos se amplifiquen.</p></li>
<li><p>Si bien estamos acostumbrados a realizar cálculos con el sistema decimal, las computadoras operan con el sistema binario. Por eso, vamos a empezar comentando qué es un sistema de numeración y en qué se diferencia el decimal del binario.</p></li>
</ul>
</section>
<section id="sistemas-de-numeración" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="sistemas-de-numeración"><span class="header-section-number">1.2</span> Sistemas de numeración</h2>
<div class="alert alert-success">
<p><strong>Definición</strong>: un <strong>sistema de numeración</strong> es un conjunto de símbolos y reglas que permiten construir todos los números válidos.</p>
</div>
<ul>
<li><p><strong>Conjunto de símbolos</strong>: en el sistema decimal usamos son los dígitos 0, 1, 2, …, 9; mientras que en el sistema binario se usan solo el 0 y el 1. En el sistema octal los símbolos son 0, 1, …, 7; en el hexadecimal son 0, 1, …, 9, A, B, C, D, E, F; y en el romano, I, V, X, L, C, D, M.</p></li>
<li><p><strong>Conjunto de reglas</strong>: indican qué operaciones son válidas. Por ejemplo, el sistema decimal es <strong>posicional</strong>, porque el valor de un dígito depende tanto del símbolo como de su posición en el número: 350 y 530 tienen los mismos dígitos pero representan magnitudes diferentes, mientras que el 5 en el primer caso aporta “50” (se posiciona en la decena), el 5 en el segundo caso aporta “500” (se posiciona el la centena). En cambio, el sistema romano es <strong>no posicional</strong>: los dígitos tienen el valor del símbolo utilizado y no depende de la posición que ocupa, sino que se va sumando o restando su valor (MMXXII = 1000 + 1000 + 10 + 10 + 1 + 1 = 2022).</p></li>
<li><p>En un sistema de numeración posicional, se le llama <strong>base</strong> al número que define el orden de magnitud en que se ve incrementada cada una de las cifras sucesivas que componen el número (y también es la cantidad de símbolos presentes en dicho sistema).</p></li>
</ul>
<section id="el-sistema-decimal" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="el-sistema-decimal"><span class="header-section-number">1.2.1</span> El sistema decimal</h3>
<div class="alert alert-success">
<p><strong>Definición</strong>: el <strong>sistema de numeración decimal</strong> es un sistema de numeración posicional cuya base es igual a 10. Los dígitos que se utilizan son 0, 1, 2, 3, 4, 5, 6, 7, 8 y 9.</p>
</div>
<ul>
<li><p>En el sistema decimal cada dígito es multiplicado por una potencia de 10, con el exponente determinado por la posición de la dígito con respecto al punto decimal.</p></li>
<li><p>Por ejemplo, el número decimal <span class="math inline">\(1563\)</span> se puede escribir en forma desarrollada utilizando potencias con base <span class="math inline">\(10\)</span> así:</p></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
1563 &amp;= 1000 + 500 + 60 + 3 \\
     &amp;= (1 \times 10^3) + (5 \times 10^2) + (6 \times 10^1) + (3 \times 10^0)
\end{aligned}
\]</span></p>
<ul>
<li><p>Entonces interpretamos que el <span class="math inline">\(1\)</span> “aporta” mil unidades porque por su posición hay que considerarlo multiplicado por la tercera potencia de 10. Lo mismo con los otros dígitos.</p></li>
<li><p>Los números con parte fraccionaria se pueden expresar así:</p>
<p><span class="math display">\[
  \begin{aligned}
  16.302 &amp;= 10 + 6 + 0.3 + 0.00 + 0.002 \\
       &amp;= (1 \times 10^1) + (6 \times 10^0) + (3 \times 10^{-1}) + (0 \times 10^{-2}) + (2 \times 10^{-3})
  \end{aligned}
  \]</span></p></li>
<li><p>Cuando usamos el sistema decimal, escribimos el “punto decimal” después del dígito que va multiplicado por <span class="math inline">\(10^0\)</span>. Por ejemplo, <span class="math inline">\(4.13\)</span> o <span class="math inline">\(2874.1\)</span>.</p></li>
<li><p>Sin embargo, esa forma de escribir los números no es práctica para trabajar con magnitudes muy grandes o muy pequeñas, porque ocupan muchos dígitos y porque es probable que muchos de ellos no provean información “exacta”.</p></li>
<li><p>En esos casos, se recurre a su representación en <strong>notación científica</strong>.</p></li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: la <strong>notación científica</strong> de un número real <span class="math inline">\(r\)</span> está compuesta por: <span class="math display">\[r = c \times b^{e}\]</span></p>
<ul>
<li><span class="math inline">\(c\)</span>: el coeficiente, formado por un número real (negativo o positvo).</li>
<li><span class="math inline">\(b\)</span>: la base (10 en el sistema decimal).</li>
<li><span class="math inline">\(e\)</span>: el exponente u “orden de magnitud”, que eleva la base a una potencia.</li>
</ul>
</div>
<ul>
<li><p>Por ejemplo:</p>
<ul>
<li>El número <span class="math inline">\(-2.3 \times 10^3\)</span> es <span class="math inline">\(-2300\)</span>. También puede escribirse <span class="math inline">\(-2.3E3\)</span> (aquí <span class="math inline">\(E\)</span> no tiene nada que ver con la constante matemática <span class="math inline">\(e=2.718282...\)</span>).</li>
<li>El número <span class="math inline">\(0.01E-7\)</span> es <span class="math inline">\(0.000000001\)</span>.</li>
<li>El número <span class="math inline">\(34E5\)</span> es <span class="math inline">\(3400000\)</span>.</li>
</ul></li>
<li><p>Se considera que el número de dígitos en el coeficiente es la cantidad de <strong>cifras o dígitos significativos</strong>. Esta expresión se usa para describir vagamente el número de dígitos decimales que parecen ser exactos, es decir, en los que se puede “confiar”, que aportan información.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p></li>
<li><p>Por ejemplo:</p>
<ul>
<li>La masa de un protón es igual a 0.00000000000000000000000000167 kg. En notación científica estándar es igual a <span class="math inline">\(1.67E-27\)</span>. Los dígitos <span class="math inline">\(1\)</span>, <span class="math inline">\(6\)</span> y <span class="math inline">\(7\)</span> son los que “importan”, tiene 3 cifras significativas.</li>
<li>La circunferencia de la Tierra en el Ecuador es <span class="math inline">\(40\,091\,000\, m\)</span>. Si en notación científica aparece como <span class="math inline">\(4.0091E7\)</span>, entendemos que presenta 5 cifras significativas y que el valor exacto tal vez ronda entre <span class="math inline">\(40\,090\,500\, m\)</span> y <span class="math inline">\(40\,091\,500\, m\)</span>.</li>
</ul></li>
</ul>
</section>
<section id="el-sistema-binario" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="el-sistema-binario"><span class="header-section-number">1.2.2</span> El sistema binario</h3>
<div class="alert alert-success">
<p><strong>Definición</strong>: el <strong>sistema de numeración binario</strong> es un sistema de numeración posicional cuya base es igual a 2. Los dígitos que se utilizan son el 0 y el 1.</p>
</div>
<ul>
<li><p>En el sistema binario el número <span class="math inline">\(1563\)</span> se escribe como <span class="math inline">\(11000011011\)</span>. Para no hacer lío, se suele usar un subíndice para señalar el sistema elegido para representar a un número: <span class="math inline">\(1563_{(10)} = 11000011011_{(2)}\)</span>.</p></li>
<li><p>¿Y cómo podemos corroborar que esto es así?</p>
<p><span class="math display">\[
\begin{aligned}
11000011011_{(2)} &amp;= (1 \times 2^{10}) + (1 \times 2^9) + (0 \times 2^8) + (0 \times 2^7) + (0 \times 2^6) + \\
&amp;~\quad (0 \times 2^5) + (1 \times 2^4) + (1 \times 2^3) + (0 \times 2^2) + (1 \times 2^1) + (1 \times 2^0) \\
&amp;= (1 \times 2^{10}) + (1 \times 2^9) + (1 \times 2^4) + (1 \times 2^3) + (1 \times 2^1) + (1 \times 2^0) \\
&amp;= 1024 + 512 + 16 + 8 + 2 + 1  \\
&amp; = 1563_{(10)}
\end{aligned}
\]</span></p></li>
<li><p>Los números binarios también admiten partes fraccionarias. Por ejemplo:</p>
<p><span class="math display">\[
  \begin{aligned}
  11.0101_{(2)} &amp;= (1 \times 2^{1}) + (1 \times 2^0) + (0 \times 2^{-1}) + (1 \times 2^{-2}) + (0 \times 2^{-3}) + (1 \times 2^{-4})\\
  &amp;= 2 + 1 + \frac{1}{4} + \frac{1}{16} \\
  &amp;= 3.3125_{(10)}
  \end{aligned}
  \]</span></p></li>
</ul>
</section>
<section id="conversión-de-decimal-a-binario" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="conversión-de-decimal-a-binario"><span class="header-section-number">1.2.3</span> Conversión de decimal a binario</h3>
<ul>
<li>En los ejemplos de arriba se vio cómo convertir de binario a decimal.</li>
<li>Ahora vamos a mencionar cómo se hace la conversión al revés.</li>
</ul>
<p><strong>Conversión de decimales enteros a binario</strong></p>
<ul>
<li><p>A la parte entera hay que dividirla sucesivamente por la base 2, hasta obtener un cociente igual a cero.</p></li>
<li><p>El conjunto de los restos de las sucesivas divisiones, ordenados desde el último hasta el primero, constituyen el número en formato binario.</p></li>
<li><p>Ejemplo:</p>
<p><span class="math display">\[
  \begin{aligned}
  123 &amp;= 61 \times 2 + 1 \\
  61 &amp;= 30 \times 2 + 1 \\
  30 &amp;= 15 \times 2 + 0 \\
  15 &amp;= 7 \times 2 + 1 \\
  7 &amp;= 3 \times 2 + 1 \\
  3 &amp;= 1 \times 2 + 1 \\
  1 &amp;= 0 \times 2 + 1\\
  \end{aligned}
  \]</span></p></li>
<li><p>De manera que <span class="math inline">\(123_{(10)} = 1111011_{(2)}\)</span>.</p></li>
</ul>
<p><strong>Conversión de números decimales fraccionarios a binario</strong></p>
<ul>
<li><p>A la parte fraccionaria hay que multiplicarla sucesivamente por 2, hasta que la misma se haga 0 o se alcance un número deseado de dígitos.</p></li>
<li><p>El conjunto de los dígitos delante de la coma forman el número binario.</p></li>
<li><p>Ejemplo: <span class="math display">\[
  \begin{aligned}
  0.3125 \times 2 = &amp; 0.625\\
  0.625 \times 2 = &amp; 1.25\\
  0.25 \times 2 = &amp; 0.5\\
  0.5 \times 2 = &amp; 1.0
  \end{aligned}
  \]</span></p></li>
<li><p>De manera que <span class="math inline">\(0.3125_{(10)} = 0.0101_{(2)}\)</span>.</p></li>
<li><p>Combinando ambos ejemplos: <span class="math inline">\(123.3125_{(10)} = 1111011.0101_{(2)}\)</span>.</p></li>
</ul>
</section>
<section id="por-qué-nos-interesa-el-sistema-binario" class="level3" data-number="1.2.4">
<h3 data-number="1.2.4" class="anchored" data-anchor-id="por-qué-nos-interesa-el-sistema-binario"><span class="header-section-number">1.2.4</span> ¿Por qué nos interesa el sistema binario?</h3>
<ul>
<li>Porque es el sistema de representación numérica que utilizan las computadoras.</li>
<li>Este sistema es natural para las computadoras ya que su memoria consiste de un enorme número de dispositivos de registro electrónico, en los que cada elemento sólo tiene los estados de “encendido” y “apagado”.</li>
<li>Estos elementos constituyen la unidad mínima de información, sólo pueden tomar dos valores posibles, <code>0</code> o <code>1</code>, y reciben el nombre de <strong>bit</strong> (<em>bi</em>nary digi<em>t</em>).</li>
<li>Aunque nosotros no nos damos cuenta, toda operación numérica que le indicamos a la computadora en sistema decimal, es traducida y procesada internamente en binario.</li>
<li>Por lo tanto es muy importante entender cómo opera la computadora, para entender qué sucede con las operaciones que queremos que realice. Por ejemplo…</li>
</ul>
<div class="alert alert-warning">
<p><strong>Ejercicio</strong>: Escribir un programa para realizar las siguientes operaciones, empleando estructuras iterativas para las sumatorias:</p>
<ol type="a">
<li><span class="math inline">\(10000 - \sum_{i=1}^{100000} 0.1\)</span></li>
<li><span class="math inline">\(10000 - \sum_{i=1}^{80000} 0.125\)</span></li>
</ol>
<p>¿Cuál es el resultado exacto en estos cálculos? ¿Qué resultados arrojó la computadora? ¿Por qué?</p>
<p><em>Respuesta</em>:</p>
<ul>
<li>Pensemos en el número decimal periódico <span class="math inline">\(1/3 = 0.\overline3\)</span>.</li>
<li>Para aproximarlo, sólo podemos usar una cantidad finita de cifras, por ejemplo, <span class="math inline">\(0.333\)</span> o <span class="math inline">\(0.33333\)</span>. Estas aproximaciones guardan cierto error, que depende de la cantidad de cifras empleadas.</li>
<li>Con los números binarios ocurre exactamente lo mismo.</li>
<li><span class="math inline">\(0.1_{(10)} = 0.0001100110011..._{(2)} = 0.0\overline{0011}_{(2)}\)</span> (verificación opcional). Es decir, la representación de 0,1 en binario es periódica, la computadora necesariamente debe redondear o truncar para almacenar y operar.</li>
<li>Por esta razón, sumar 100 mil veces <span class="math inline">\(0,1\)</span> no da exactmente 10000.</li>
<li>Por el contrario, <span class="math inline">\(0.125\)</span> en binario no es periódico, la computadora lo puede representar exactamente y no se produjo error.</li>
</ul>
<p><em>Actividad opcional</em>: verificar <span class="math inline">\(0.1_{(10)} = 0.0\overline{0011}_{(2)}\)</span> y encontrar la representación binaria de <span class="math inline">\(0.125_{(10)}\)</span>.</p>
</div>
<!-- 
RESPUESTA
- Pasemos a binario el número decimal $1/10 = 0,1_{(10)}$

$$
\begin{aligned}
0,1 \times 2 = 0,2 \\
0,2 \times 2 = 0,4 \\
0,4 \times 2 = 0,8 \\
0,8 \times 2 = 1,6 \\
0,6 \times 2 = 1,2 \\
0,2 \times 2 = 0,4 \\
0,4 \times 2 = 0,8
\end{aligned}
$$

y la secuencia sigue repitiéndose...

- Es decir que $0,1_{(10)} = 0,0001100110011..._{(2)} = 0,0\overline{0011}_{(2)}$

$$
\begin{aligned}
0,125 \times 2 = 0,25 \\
0,25 \times 2 = 0,5 \\
0,5 \times 2 = 1,0
\end{aligned}
$$
Es decir que $0,125_{(10)} = 0,001_{(2)}$.
-->
</section>
</section>
<section id="números-de-máquina-binarios" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="números-de-máquina-binarios"><span class="header-section-number">1.3</span> Números de máquina binarios</h2>
<ul>
<li><p>Ya sabemos que la computadora emplea el sistema binario. Ahora bien, ¿cómo se organiza para almacenar los números?</p></li>
<li><p>Utiliza un sistema conocido como <strong>representación de punto (o coma) flotante</strong> (en inglés, <em>floating point</em>).</p></li>
<li><p>Existe un protocolo que es usado por todas las computadoras actuales y que establece las reglas para este tipo de representación.</p></li>
<li><p>Se lo conoce como <strong>IEEE-754</strong> ya que fue publicado por el <em>Institute for Electrical and Electronic Engineers</em> en 1985 y actualizado en 2008.</p></li>
<li><p>Este estándar define dos tipos de formatos: el de <em>precisión simple</em> (en el cual cada número ocupa 32 bit de memoria) y el de <em>precisión doble</em> (un número ocupa 64 bit).</p></li>
<li><p>El formato de doble precisión en 64 bit, empleado actualmente en casi todas las computadoras, establece que todo número real es representado por la computadora con una aproximación binaria del tipo:</p>
<p><span class="math display">\[
(-1)^s \times 2^{c-01111111111} \times (1 + f)
\]</span></p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U1/float64_2.png" class="img-fluid" style="width:90.0%"></p>
</div>
</div>
<ul>
<li><p>El primer bit es indicador de <strong>signo</strong>, <span class="math inline">\(s\)</span>: vale 0 si el número es positivo o 1 si es negativo.</p></li>
<li><p>Le sigue un <strong>exponente</strong> o <strong>característica</strong> <span class="math inline">\(c\)</span> que ocupa 11 bits dando lugar a <span class="math inline">\(2^{11} = 2048\)</span> valores distintos, entre el 0 y 2047. Sin embargo, a <span class="math inline">\(c\)</span> se le resta <span class="math inline">\(01111111111_{(2)} = 1023_{(10)}\)</span> para tener exponentes negativos y positivos entre -1023 y 1024, lo cual produce una mejora en la representación de números con magnitud pequeña.</p></li>
<li><p>Finalmente, la representación termina con una <strong>fracción</strong> binaria de 52 bits que se llama <strong>mantisa</strong>, <span class="math inline">\(f\)</span>.</p></li>
</ul>
<!-- 
- Otras curiosidades:

- La representación en coma flotante no es necesariamente única, de ahí que surge la llamada "representación normalizada", en la cual el primer dígito de la mantisa debe ser 1.

    - Los ceros con signo: si el exponente y la mantisa son ceros, el número es +0 o -0 dependiendo del signo.
    - El caso de e = 2047 (los 11 dígitos del exponenete son 1) se reserva para codificar +- infty y otros objetos que se denominan NaN (Not-a-Number), que indica que una operación es ilegítima, como 1/0 o log(-2) en una operación con números reales. -->
<ul>
<li><p>Ejemplo: el siguiente conjunto de 64 bits representa al número decimal <span class="math inline">\(74.5\)</span>:</p>
<p><span class="math display">\[
  0100000001010010101000000000000000000000000000000000000000000000
  \]</span></p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U1/floatej.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<div class="alert alert-info">
<p><strong>Verificación opcional del ejemplo</strong>:</p>
<ul>
<li><p>Primero el exponente: <span class="math inline">\(c=10000000101_{(2)}=2^{10}+2^{2}+2^{0}=1029_{(10)}, \quad 1029-1023=6\)</span>.</p></li>
<li><p>Luego la mantisa (recordar que es fraccionaria):</p>
<p><span class="math display">\[
  \begin{aligned}
  0010101_{(2)} &amp;= 0 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} +  0 \times 2^{-4} + 1 \times 2^{-5} + 0 \times 2^{-6} + 1 \times 2^{-7} \\
  &amp;= 1 \times 2^{-3} + 1 \times 2^{-5} + 1 \times 2^{-7} \\
  &amp;= \frac{1}{8} + \frac{1}{32} + \frac{1}{128} \\
  &amp;= 0.1640625_{(10)}
  \end{aligned}
  \]</span></p></li>
<li><p>Juntando todo:</p>
<p><span class="math display">\[
  (-1)^0 \times 2^{1029-1023} \times (1 + 0.1640625) = (-1) \times 64 \times 1.1640625 = 74.5_{(10)}
  \]</span></p></li>
<li><p>En <a href="http://weitz.de/ieee/">este link</a> o en <a href="https://www.ultimatesolver.com/en/ieee-754">este otro</a> se puede encontrar una calculadora que convierte números entre sus representaciones en decimal y en coma flotante.</p></li>
</ul>
</div>
<ul>
<li>A través de este sistema, las computadoras sólo pueden representar un subconjunto de los números racionales y no pueden representar números irracionales como <span class="math inline">\(\pi\)</span> o <span class="math inline">\(\sqrt3\)</span> dado que tienen infinitos decimales no periódicos.</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U1/floatingPoint.jpg" class="img-fluid" style="width:50.0%"></p>
</div>
</div>
<ul>
<li><p>Esto hace que en la representación surjan los errores de redondeo mencionados en ejemplos anteriores.</p></li>
<li><p>Por ejemplo, este era el número de máquina del ejemplo:</p></li>
</ul>
<p><span class="math display">\[
0100000001010010101000000000000000000000000000000000000000000000
\]</span></p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U1/floatej2.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<ul>
<li>Este es el número más grande que le sigue. En decimal, es <span class="math inline">\(74.500000000000014210854715\)</span>:</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U1/floatej3.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<ul>
<li>Este es el número más chico que le sigue. En decimal, es <span class="math inline">\(74.499999999999985789145284\)</span>:</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U1/floatej4.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<ul>
<li><p>Esto significa el número de máquina <span class="math display">\[0100000001010010101000000000000000000000000000000000000000000000\]</span> no solo representa al <span class="math inline">\(74.5\)</span>, sino aproximadamente a la mitad de los números que están entre <span class="math inline">\(74.499999999999985789145284\)</span> y <span class="math inline">\(74.500000000000014210854715\)</span>.</p></li>
<li><p>El número positivo normalizado más pequeño que se puede representar tiene <span class="math inline">\(s=0\)</span>, <span class="math inline">\(c=1\)</span> y <span class="math inline">\(f=0\)</span> y es equivalente a :</p>
<p><span class="math display">\[
  2^{-1022} \approx 0.22251 \times 10^{-307}
  \]</span></p></li>
<li><p>Los números que se presentan en los cálculos que tienen una magnitud menor que esa resultan en un <strong>subdesbordamiento</strong> (<em>underflow</em>) y, en general, se configuran en cero.</p></li>
<li><p>El número positivo normalizado más grande que se puede representar tiene <span class="math inline">\(s=0\)</span>, <span class="math inline">\(c=2046\)</span> y <span class="math inline">\(f=1 - 2^{-52}\)</span> y es equivalente a :</p>
<p><span class="math display">\[
  2^{1023} \times (2-2^{-52}) \approx 0.17977 \times 10^{309}
  \]</span></p></li>
<li><p>Los números superiores resultan en <strong>desbordamiento</strong> (<em>overflow</em>) y, comúnmente, causan que los cálculos se detengan.</p></li>
</ul>
<!-- explicacion por que ese es el maximo -->
<!-- https://www.quora.com/Why-is-the-largest-single-precision-IEEE-754-binary-floating-point-number-2%E2%88%922-%E2%88%9223-%C3%97-2-127 -->
</section>
<section id="poda-redondeo-y-medida-del-error" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="poda-redondeo-y-medida-del-error"><span class="header-section-number">1.4</span> Poda, redondeo y medida del error</h2>
<ul>
<li><p>En la sección anterior quedó en claro que la computadora solo puede trabajar con una aproximación finita de cualquier número que nos interese.</p></li>
<li><p>Muchos “problemas” pueden generarse por esta situación.</p></li>
<li><p>Para examinar estos problemas y medir los errores de redondeo, utilizaremos números decimales, ya que nos resultan más familiares que los binarios.</p></li>
<li><p>Vamos a considerar que para representar a los números estamos restringidos a usar el siguiente <strong>formato normalizado de punto flotante decimal</strong>:</p>
<p><span class="math display">\[
  \pm 0.d_1d_2\cdots d_k \times 10^n, \quad 1 \leq d_1 \leq 9 \quad y \quad 0 \leq d_i \leq 9 \quad i=2,\cdots, k
  \]</span></p></li>
<li><p>Cualquier real <span class="math inline">\(y\)</span> puede ser expresado en un formato normalizado como ese, pero claro, usando cualquier cantidad de dígitos (a veces infinitos):</p>
<p><span class="math display">\[
  y = \pm 0.d_1d_2\cdots d_k d_{k+1} d_{k+2} ... \times 10^n
  \]</span></p></li>
<li><p>Cuando un número se informa de esta manera, generalmente se considera que la cantidad de dígitos que están en la mantisa (los <span class="math inline">\(d_i\)</span>) son los <strong>dígitos o cifras significativas</strong> del número.</p></li>
<li><p>Para emular la aritmética finita que manejan las computadoras, hay que restringir la representación de <span class="math inline">\(y\)</span> a nuestro sistema que sólo permite <span class="math inline">\(k\)</span> dígitos en la mantisa. A esto le decimos <em>forma de punto flotante de <span class="math inline">\(y\)</span></em> y se denota <span class="math inline">\(fl(y)\)</span>.</p></li>
<li><p>Existen dos formas de “quedarnos” sólo con <span class="math inline">\(k\)</span> dígitos:</p></li>
</ul>
<div class="alert alert-success">
<p>El <strong>método de corte o poda</strong> consiste en simplemente cortar los dígitos <span class="math inline">\(d_{k+1} d_{k+2} ...\)</span>, produciendo:</p>
<p><span class="math display">\[
fl(y) = \pm 0.d_1d_2\cdots d_k  \times 10^{n}
\]</span></p>
</div>
<ul>
<li><p>Por ejemplo, el número <span class="math inline">\(\pi\)</span> tiene una expansión decimal infinita de la forma <span class="math inline">\(\pi = 3.14159265...\)</span>. Escrito en forma normalizada es: <span class="math inline">\(\pi = 0.314159265... \times 10^{1}\)</span>. Si tenemos que representarlo con <span class="math inline">\(k=5\)</span> dígitos usando poda, el formato de punto flotante de <span class="math inline">\(\pi\)</span> es:</p>
<p><span class="math display">\[
  fl(\pi) = 0.31415 \times 10^{1}
  \]</span></p></li>
</ul>
<div class="alert alert-success">
<p>El <strong>método de redondeo</strong> consiste en sumarle 1 a <span class="math inline">\(d_k\)</span> si <span class="math inline">\(d_{k+1} \geq 5\)</span> (<em>redondear hacia arriba</em>) o cortarlo reteniendo los primeros <span class="math inline">\(k\)</span> dígitos si <span class="math inline">\(d_{k+1} \leq 5\)</span> (<em>redondear hacia abajo</em>)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Esto hace que los dígitos puedan quedar distintos, entonces:</p>
<p><span class="math display">\[
fl(y) = \pm 0.\delta_1\delta_2\cdots \delta_k  \times 10^{n}
\]</span></p>
<p>Si se redondea hacia abajo, <span class="math inline">\(\delta_i = d_i \, \forall i\)</span>, pero si se redondea hacia arriba pueden cambiar los dígitos e incluso el exponente.</p>
</div>
<ul>
<li><p>En el ejemplo anterior, como el sexto dígito de la expansión decimal de <span class="math inline">\(\pi\)</span> es un 9, el formato de punto flotante con redondeo de cinco dígitos es:</p>
<p><span class="math display">\[
  fl(\pi) = 0.31416 \times 10^{1} = 3.1416
  \]</span></p></li>
<li><p>Tener que aproximar a <span class="math inline">\(\pi\)</span> con un formato de precisión finita introduce error.</p></li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: se llama <strong>error de redondeo</strong> al error que resulta de reemplazar un número por su forma de punto flotante (independientemente de si se usa el método de redondeo o de poda)</p>
</div>
<ul>
<li>Vamos a definir tres formas de medir errores de aproximación.</li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: sea <span class="math inline">\(p^*\)</span> una aproximación a <span class="math inline">\(p\)</span>.</p>
<ul>
<li><strong>Error real</strong>: <span class="math inline">\(E = p - p^*\)</span></li>
<li><strong>Error absoluto</strong>: <span class="math inline">\(EA = |p - p^*|\)</span></li>
<li><strong>Error relativo</strong>: <span class="math inline">\(ER = \frac{|p - p^*|}{|p|}\)</span>, siempre que <span class="math inline">\(p \neq 0\)</span>.</li>
</ul>
</div>
<ul>
<li><p>El error real y el absoluto se miden en la misma unidad de la variable que se trata de aproximar, mientras que el error relativo se puede interpretar como un porcentaje y es independiente de las unidades de medida.</p></li>
<li><p>En general, el error relativo es una mejor medición de precisión que el error absoluto porque considera el tamaño del número que se va a aproximar (ver ejemplo 2 de la página 14 del libro de Burden).</p></li>
<li><p>A veces no se puede encontrar un valor preciso para el error verdadero en una aproximación, pero se puede encontrar una cota para el error, lo cual proporciona una idea de cuál es “el peor error posible”.</p></li>
<li><p>Por ejemplo, se puede demostrar que si representamos a un real <span class="math inline">\(y\)</span> en el formato de punto flotante decimal de <span class="math inline">\(k\)</span> dígitos visto antes con poda, el error relativo de la aproximación queda acotado por:</p>
<p><span class="math display">\[
  ER = \Bigg\rvert \frac{y - fl(y)}{y} \Bigg\rvert \leq 10^{-k+1}
  \]</span> y si se usa redondeo:</p>
<p><span class="math display">\[
  ER = \Bigg\rvert \frac{y - fl(y)}{y} \Bigg\rvert \leq 0.5 \times 10^{-k+1}
  \]</span></p></li>
<li><p>Estas cotas para el error relativo son independientes del número que se va a representar y esto se debe a que la cantidad de números de máquina decimales que se pueden representar en cada intervalo <span class="math inline">\([10^n, 10^{n+1}]\)</span> es la misma para todo <span class="math inline">\(n\)</span>. Es decir, este formato admite la representación de la misma cantidad de números dentro de cada uno de estos intervalos: <span class="math inline">\([0.1, 1]\)</span>, <span class="math inline">\([1, 10]\)</span>, <span class="math inline">\([10, 100]\)</span>, etc.</p></li>
</ul>
</section>
<section id="aritmética-de-dígitos-finitos" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="aritmética-de-dígitos-finitos"><span class="header-section-number">1.5</span> Aritmética de dígitos finitos</h2>
<ul>
<li><p>Ya vimos que tenemos el problema de que la representación de los números no es exacta.</p></li>
<li><p>A esto se le suma el inconveniente de que la aritmética que se efectúa en una computadora tampoco es exacta.</p></li>
<li><p>La mecánica real de las operaciones aritméticas que realiza la computadora manipulando los bits es compleja, por eso vamos a seguir ejemplificando estas cuestiones con el sistema decimal, operando bajo un formato de punto flotante restringido a <span class="math inline">\(k\)</span> dígitos.</p></li>
<li><p>Si queremos sumar dos números reales <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span>, primero tenemos que buscar su representación de punto flotante, <span class="math inline">\(fl(x)\)</span> y <span class="math inline">\(fl(y)\)</span>, luego hacemos la suma entre ellas <span class="math inline">\(fl(x) + fl(y)\)</span> y a este resultado lo expresamos en punto flotante. Por lo tanto, la suma entre <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> es representada por:</p>
<p><span class="math display">\[
  fl(fl(x) +fl(y))
  \]</span></p></li>
<li><p>Hacemos lo mismo con otras operaciones.</p></li>
</ul>
<div class="alert alert-info">
<p><strong>Ejemplo</strong>: utilizar el corte de cinco dígitos para calcular <span class="math inline">\(x+y\)</span>, <span class="math inline">\(x-y\)</span>, <span class="math inline">\(x \times y\)</span> y <span class="math inline">\(x/y\)</span> para <span class="math inline">\(x=5/7\)</span> e <span class="math inline">\(y=1/3\)</span></p>
<p><span class="math display">\[
fl(x) = 0.71428 \times 10^0 \qquad fl(y) = 0.33333 \times 10^0
\]</span></p>
<ul>
<li><p><em>Suma</em>. La representación de <span class="math inline">\(x+y\)</span> en punto flotante es: <span class="math inline">\(0.10476 \times 10^1\)</span>:</p>
<p><span class="math display">\[
  fl(0.71428 \times 10^0 + 0.33333 \times 10^0) = fl(1.04761) = 0.10476 \times 10^1
  \]</span></p>
<p>Siendo el valor verdadero <span class="math inline">\(5/7 + 1/3 = 22/21\)</span>, tenemos:</p>
<p><span class="math display">\[
  EA = \Bigg \rvert \frac{22}{21} - 0.10476 \times 10^{1} \Bigg \rvert = 0.000019048 = 0.190 \times 10^{-4}
  \]</span> <span class="math display">\[
  ER = \Bigg \rvert \frac{0.19048 \times 10^{-4}}{22/21} \Bigg \rvert = 0.000018182 = 0.181 \times 10^{-4}
  \]</span></p></li>
<li><p>Realizar los cálculos para las otras operaciones.</p></li>
</ul>
</div>
<ul>
<li><p>El ejemplo anterior ilustra que los errores son inherentes a la aritmética finita que realizan las computadoras.</p></li>
<li><p>Particularmente, hay algunos tipos de operaciones conocidos por ser particularmente problemáticos:</p></li>
<li><p><strong>Sustracción de números casi iguales</strong>:</p>
<ul>
<li>Cuando se restan números similares el resultado tiene menos cifras significativas que los valores originales (<strong>pérdida de cifras significativas</strong> o <strong>cancelación catastrófica</strong>).</li>
<li>Por ejemplo: sean <span class="math inline">\(p = 0.54617 \times 10^0\)</span> y <span class="math inline">\(q = 0.54601 \times 10^0\)</span>. Si usamos una aritmética de 5 dígitos para aproximar <span class="math inline">\(p - q\)</span> nos queda:</li>
</ul>
<p><span class="math display">\[
  fl( 0.54617 \times 10^0 - 0.54601 \times 10^0) = fl(0.00016 \times 10^0) = 0.16 \times 10^{-3}
  \]</span></p>
<ul>
<li>Mientras que <span class="math inline">\(p\)</span> y <span class="math inline">\(q\)</span> tenían 5 cifras significativas cada uno, la aproximación para la resta solo tiene 2.</li>
<li>Esto puede producir una reducción en la precisión final de la respuesta calculada.</li>
</ul></li>
<li><p><strong>Adición de un número grande y uno pequeño</strong>:</p>
<ul>
<li><p>Puede hacer que el pequeño desaparezca.</p></li>
<li><p>Por ejemplo: sean <span class="math inline">\(p = 0.96581 \times 10^{5}\)</span> y <span class="math inline">\(q = 0.37712 \times 10^{0}\)</span>. Se debe sumarlo usando una aritmética de 5 dígitos:</p>
<p><span class="math display">\[
  \begin{aligned}
  fl(0.96581 \times 10^{5} + 0.37712 \times 10^{0}) &amp;= fl(96581 \times 10^{0} + 0.37712 \times 10^{0}) \\
  &amp;= fl(96581.37712 \times 10^{0}) \\
  &amp;= 0.96581 \times 10^{5} \\
  &amp;= p
  \end{aligned}
  \]</span></p></li>
<li><p>En ciertos casos esto no ocasiona un problema ya que, si tenemos un número de gran magnitud probablemente podamos considerar al más pequeño despreciable.</p></li>
<li><p>Sin embargo debe tenerse mucho cuidado con el orden de las operaciones. Por ejemplo, si sumamos una gran cantidad de números pequeños entre ellos (que juntos tienen un peso considerable) y luego se lo sumamos a un número grande, todo funcionará correctamente. Pero si partimos del número grande y le vamos sumando uno por uno los números pequeños, en cada paso el número pequeño será considerado despreciable y llegaremos a un resultado erróneo.</p></li>
</ul></li>
<li><p><strong>División por cantidades pequeñas</strong></p>
<ul>
<li>Un error mínimo en el dividendo se traduce en uno mucho mayor en el resultado, de modo que la falta de precisión podría ocasionar un error por desbordamiento o pérdida de cifras significativas.</li>
<li>Esto se da porque los números de punto flotante están más concentrados cerca del cero entonces al dividir por un número más grande es más probable conseguir una mejor aproximación.</li>
</ul></li>
<li><p>Estas operaciones “delicadas”, la noción que el orden de las operaciones influye en la precisión y las consideraciones que hay que hacer para operar dentro del formato de punto flotante soportado por la máquina (por ejemplo, evaluar en todo tiempo si se va a producir un desbordamiento o subdesbordamiento), hacen que implementar algoritmos sea una actividad no trivial, que hay que dejar en manos de expertos.</p></li>
<li><p>A la hora de escribir programas para aplicar métodos numéricos, en general saltearemos esa parte. Los programas que escribiremos funcionarán bien dentro del contexto de este curso y nos van a servir para entender el funcionamiento de cada método.</p></li>
<li><p>Sin embargo, para otros contextos será mejor si hacemos uso de software desarrollado por especialistas.</p></li>
<li><p>A modo ilustrativo, en la página 29 del libro de Burden se puede ver un algoritmo “casero” para calcular una distancia euclidea (algo así podemos llegar a implementar nosotros), mientras que en las páginas 30 y 31 se presenta un algoritmo más “profesional”, que resuelve el mismo problema teniendo más cuidados.</p></li>
</ul>
</section>
<section id="estabilidad-de-los-algoritmos" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="estabilidad-de-los-algoritmos"><span class="header-section-number">1.6</span> Estabilidad de los algoritmos</h2>
<ul>
<li>Hemos visto que la aritmética con dígitos finitos puede introducir errores. Si un algoritmo propone realizar cálculos sucesivos, estos errores pueden empezar a acumularse.</li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: el <strong>error propagado</strong> es el error que se tiene al final de una cadena de operaciones sucesivas por la existencia de diferentes errores en los pasos intermedios.</p>
</div>
<ul>
<li><p>Por ejemplo, si tenemos dos valores exactos <span class="math inline">\(p\)</span> y <span class="math inline">\(q\)</span> con valores aproximados <span class="math inline">\(p^*\)</span> y <span class="math inline">\(q^*\)</span> cuyos errores reales son <span class="math inline">\(E_p\)</span> y <span class="math inline">\(E_q\)</span> de modo que <span class="math inline">\(p^* = p - E_p\)</span> y <span class="math inline">\(q^* = q - E_q\)</span>, al realizar la suma entre los valores aproximados encontramos que el error propagado es <span class="math inline">\(- E_p - E_q\)</span>:</p>
<p><span class="math display">\[p^* + q^* = (p - E_p) + (q - E_q) = (p + q) + (-E_p - E_q)\]</span></p></li>
<li><p>Si bien es normal que en una cadena los errores iniciales se propaguen, es deseable que un error pequeño en el comienzo produzca errores pequeños en el resultado final.</p></li>
<li><p>Un algoritmo con esta cualidad se llama <strong>estable</strong> (el error se puede acotar). En caso contrario se dice <strong>inestable</strong>.</p></li>
<li><p>Supongamos que <span class="math inline">\(E_0&gt;0\)</span> representa un error inicial y que <span class="math inline">\(E_n\)</span> representa la magnitud del error después de <span class="math inline">\(n\)</span> operaciones:</p>
<ul>
<li>Si <span class="math inline">\(E_n \approx C \times n \times E_0\)</span>, para alguna constante <span class="math inline">\(C\)</span> el crecimiento del error es <strong>lineal</strong> (el algoritmo es <strong>estable</strong>)</li>
<li>Si <span class="math inline">\(E_n \approx C^n \times E_0\)</span>, para alguna constante <span class="math inline">\(C&gt;1\)</span> el crecimiento del error es <strong>exponencial</strong> y no se puede acotar (el algoritmo es <strong>inestable</strong>).</li>
</ul>
<p><!-- - Si $E_n \approx C^n E_0$, para alguna constante $C<1$ el error decrece **exponencialmente** y se puede acotar. --></p></li>
<li><p>Normalmente el crecimiento lineal del error es inevitable y cuando <span class="math inline">\(C\)</span> y <span class="math inline">\(E_0\)</span> son pequeñas, en general, los resultados son aceptables.</p></li>
<li><p>El crecimiento exponencial del error debería evitarse porque el término <span class="math inline">\(C^n\)</span> puede volverse grande incluso para valores relativamente pequeños de <span class="math inline">\(n\)</span>, conduciendo a imprecisiones inaceptables.</p></li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<p><img src="Plots/U1/crecimiento.png" class="img-fluid quarto-figure-center" style="width:80.0%"></p>
</div>
</div>


</section>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Hay algunas reglas para determinar cuántas cifras significativas tienen los números que no estén expresados en un formato normalizado de punto flotante decimal, pero no nos vamos a preocupar por eso.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Hay otros métodos de redondeo más sofisticados.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./index.html" class="pagination-link  aria-label=" prefacio"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Prefacio</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>