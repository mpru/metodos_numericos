[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Métodos Numéricos con Python",
    "section": "",
    "text": "Prefacio\nEl presente documento es la guía de estudio para la asignatura Métodos Numéricos de la Licenciatura en Estadística (Universidad Nacional de Rosario). Se ha utilizado como fuente para la creación de este material a la bibliografía mencionada en el programa de la asignatura. La asignatura se complementa con variados materiales (prácticas, ejemplos, proyectos) disponibles en el aula virtual del curso de acceso privado.\nEstos apuntes no están libres de contener errores. Sugerencias para corregirlos o para expresar de manera más adecuada las ideas volcadas son siempre bienvenidas1.\nPrimera publicación: enero 2024.\n\n\n\n\n\n\nEn general, no se cuenta con derechos para las imágenes empleadas (a menos que sean de creación propia). Ante cualquier problema, contactar al autor.↩︎",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "06_aprox_polin_parte1.html#introducción",
    "href": "06_aprox_polin_parte1.html#introducción",
    "title": "1  Aproximación polinomial - Parte 1: interpolación",
    "section": "1.1 Introducción",
    "text": "1.1 Introducción\n\nUna de las clases más útiles y conocidas de funciones que mapean el conjunto de números reales en sí mismo son los polinomios algebraicos:\n\\[\n  P_n(x) = a_{n} x^{n} +a_{n-1} x^{n-1} +...+a_{1} x + a_0\n  \\]\ndonde \\(n\\) es un entero positivo y \\(a_0, ..., a_n\\) son constantes reales.\nUna razón de su importancia es que se aproximan de manera uniforme a las funciones continuas.\nEs decir, dada una función definida y continua sobre un intervalo cerrado y acotado, existe un polinomio que está tan “cerca” de la función dada como se desee. Ver teorema 3.1 (Weierstrass) y Figura 3.1 (página 78).\nPor esta razón, empleamos polinomios para aproximar el valor de una función \\(f(x)\\) en un intervalo de interés (es decir, para realizar interpolación) y también para aproximar derivadas e integrales.\nEnglobamos a las técnicas que permiten cumplir con esos objetivos bajo el nombre de métodos de aproximación polinomial.\nObservación: los polinomios de Taylor son esenciales en muchos aspectos del análisis numérico porque permiten aproximar el valor de una función alrededor de un punto específico. Sin embargo, la aproximación polinomial no se basa en el uso de polinomios de Taylor. Leer páginas 78 y 79.\nEn este apunte vamos a tratar el tema de la interpolación.\nPreparativos para los ejemplos en Python:\n\n\n# Algunas librerías y funciones necesarias\nfrom unidad6_funciones import *\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy.polynomial.polynomial as npol",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aproximación polinomial - Parte 1: interpolación</span>"
    ]
  },
  {
    "objectID": "06_aprox_polin_parte1.html#polinomios-de-interpolación-de-lagrange",
    "href": "06_aprox_polin_parte1.html#polinomios-de-interpolación-de-lagrange",
    "title": "1  Aproximación polinomial - Parte 1: interpolación",
    "section": "1.2 Polinomios de interpolación de Lagrange",
    "text": "1.2 Polinomios de interpolación de Lagrange\n\n1.2.1 Fórmula\n\nVamos a considerar el problema en el que contamos con los valores que toma una función de interés \\(f\\) en los \\(n+1\\) puntos \\(x_0, x_1, ..., x_n\\) (es decir, conocemos \\(f(x_0), ..., f(x_n)\\)) y queremos aproximar el valor de \\(f(x)\\) para otros valores \\(x\\).\n\n\nDefinición: la interpolación es el uso de polinomios que coinciden con una función \\(f\\) en puntos determinados dentro de un intervalo para aproximar el valor de \\(f\\) en otros puntos dentro del mismo intervalo.\n\n\nA los valores \\(x_i\\) para los cuales tenemos \\(f(x_i)\\) les decimos nodos y a estos pares de valores los presentamos en una tabla como la siguiente:\n\n\n\n\n\n\n\n\nPor ejemplo:\n\n\n\ni\n\\(x_i\\)\n\\(f(x_i)\\)\n\n\n\n\n0\n-1\n0.5403\n\n\n1\n0\n1.0000\n\n\n2\n2\n-0.4162\n\n\n3\n2.5\n-0.8011\n\n\n\nPensemos en que estamos estudiando una función \\(f\\) para la cual conocemos los valores \\(f(x_0)\\) y \\(f(x_1)\\) y necesitamos aproximar cuánto vale \\(f(x)\\) para algún \\(x\\) entre \\(x_0\\) y \\(x_1\\).\n¿Qué se nos ocurre hacer?\nPodemos trazar una recta que una los puntos \\((x_0, f(x_0))\\) y \\((x_1, f(x_1))\\) y utilizar como aproximación el valor de esta recta para el \\(x\\) de interés.\nEso equivale a utilizar un polinomio de grado 1 (una recta) para hacer la interpolación.\nDe nuestros conocimientos de geometría sabemos que la ecuación de la recta que pasa por dos puntos \\((x_0, f(x_0))\\) y \\((x_1, f(x_1))\\) es:\n\\[\n  P_1(x) = f(x_0) + \\frac{f(x_1) - f(x_0)}{x_1 - x_0} (x - x_0)\n  \\]\nEsto se puede reescribir como:\n\\[\n  P_1(x) = \\underbrace{\\frac{x - x_1}{x_0 - x_1}}_{L_0(x)} f(x_0) + \\underbrace{\\frac{x - x_0}{x_1 - x_0}}_{L_1(x)} f(x_1) = L_0(x) f(x_0) + L_1(x) f(x_1)\n  \\]\nPodemos comprobar que dicha recta para por \\((x_0, f(x_0))\\) y \\((x_1, f(x_1))\\) (sustituir \\(x\\) y verificar).\nImportante: \\(P(x)\\) es el único polinomio de grado 1 que pasa por dichos puntos. Podríamos reescribirlo de muchas formas, pero es un polinomio único (en este caso, es la única recta).\nEsta expresión se puede extender para obtener polinomios de grados superiores que pasen por más puntos.\nPor ejemplo, el polinomio que pasa por los puntos \\((x_0, f(x_0))\\), \\((x_1, f(x_1))\\) y \\((x_2, f(x_2))\\) es:\n\n\\[\nP_2(x) =\n\\underbrace{\\frac{(x - x_1)(x - x_2)}{(x_0 - x_1)(x_0 - x_2)}}_{L_0(x)} f(x_0) +\n\\underbrace{\\frac{(x - x_0)(x - x_2)}{(x_1 - x_0)(x_1 - x_2)}}_{L_1(x)} f(x_1) +\n\\underbrace{\\frac{(x - x_0)(x - x_1)}{(x_2 - x_0)(x_2 - x_1)}}_{L_2(x)} f(x_2)\n\\]\n\nSe puede ver fácilmente que este polinomio pasa exactamente por los tres puntos dados.\nDe la misma forma, el polinomio de grado 3 que pasa por cuatro puntos \\((x_0, f(x_0))\\), \\((x_1, f(x_1))\\), \\((x_2, f(x_2))\\) y \\((x_3, f(x_3))\\) es:\n\n\\[\n\\begin{split}\nP_3(x) = &~ \\frac{(x - x_1)(x - x_2)(x - x_3)}{(x_0 - x_1)(x_0 - x_2)(x_0 - x_3)} f(x_0) + \\frac{(x - x_0)(x - x_2)(x - x_3)}{(x_1 - x_0)(x_1 - x_2)(x_1 - x_3)} f(x_1) \\\\\n& + \\frac{(x - x_0)(x - x_1)(x - x_3)}{(x_2 - x_0)(x_2 - x_1)(x_2 - x_3)} f(x_2) + \\frac{(x - x_0)(x - x_1)(x - x_2)}{(x_3 - x_0)(x_3 - x_1)(x_3 - x_2)} f(x_3)\n\\end{split}\n\\]\n\nSe puede ver fácilmente que este polinomio pasa exactamente por los cuatro puntos dados.\nGeneralizando la idea anterior se obtiene la fórmula de interpolación de Lagrange.\n\n\nTeorema: Si \\(x_0, x_1, ..., x_n\\) son \\(n+1\\) números distintos y \\(f\\) es una función cuyos valores están determinados en estos números, entonces existe un único polinomio \\(P(x)\\) de grado a lo sumo \\(n\\) con\n\\[\nf(x_k) = P(x_k) \\qquad \\forall \\, k = 0, 1, ..., n\n\\]\nEste polinomio recibe el nombre de enésimo polinomio de interpolación de Lagrange y está determinado por:\n\\[\nP_n(x) =  L_{n,0}(x) f(x_0) + ... + L_{n,n}(x) f(x_n) = \\sum_{k=0}^{n} f(x_k) L_{n,k}(x),\n\\]\ndonde para cada \\(k=0,1, ..., n\\):\n\\[\nL_{n,k}(x) =\n\\frac{(x-x_0)(x-x_1)...(x-x_{k-1})(x-x_{k+1})...(x-x_{n})}\n{(x_k-x_0)(x_k-x_1)...(x_k-x_{k-1})(x_k-x_{k+1})...(x_k-x_{n})}\n= \\prod^{n}_{\\substack{i=0 \\\\ i \\neq k}} \\frac{x-x_i}{x_k-x_i}\n\\]\n\n\nCuando no hay confusión acerca del valor de \\(n\\) escribimos directamente \\(L_k(x)\\) en lugar de \\(L_{n,k}(x)\\).\nLa función \\(L_{n,k}(x)\\) hace que el polinomio pase por los puntos dados debido a que \\(L_{n,k}(x_i) = 0\\) cuando \\(i\\neq k\\) y \\(L_{n,k}(x_k) = 1\\) cuando \\(i = k\\).\n\n\n\n1.2.2 Ejemplo\n\nEmplear el método de Lagrange para interpolar el valor de la función \\(f\\) en \\(x=2.25\\), con el polinomio interpolante de grado 3 que pasa por los cuatro puntos tabulados:\n\n\n\ni\n\\(x_i\\)\n\\(f(x_i)\\)\n\n\n\n\n0\n-1\n0.5403\n\n\n1\n0\n1.0000\n\n\n2\n2\n-0.4162\n\n\n3\n2.5\n-0.8011\n\n\n\n\n\n# Crear un DataFrame con los datos\ndatos = pd.DataFrame({'x': [-1, 0, 2, 2.5], 'y': [0.5403, 1, -0.4162, -0.8011]})\n\n# Crear el gráfico\nplt.figure(figsize=(8, 6))\nplt.grid(True)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n\n\n\n\n\\[\n\\begin{split}\nP_3(x) &=  \\sum_{k=0}^{3} f(x_k) \\Big(  \\prod^{3}_{\\substack{i=0 \\\\ i \\neq k}} \\frac{x-x_i}{x_k-x_i} \\Big) \\\\\n&= f(x_0) \\frac{(x - x_1)(x - x_2)(x - x_3)}{(x_0 - x_1)(x_0 - x_2)(x_0 - x_3)}  \\\\ \\\\\n&+f(x_1) \\frac{(x - x_0)(x - x_2)(x - x_3)}{(x_1 - x_0)(x_1 - x_2)(x_1 - x_3)}  \\\\ \\\\\n&+f(x_2)\\frac{(x - x_0)(x - x_1)(x - x_3)}{(x_2 - x_0)(x_2 - x_1)(x_2 - x_3)}   \\\\ \\\\\n&+f(x_3)\\frac{(x - x_0)(x - x_1)(x - x_2)}{(x_3 - x_0)(x_3 - x_1)(x_3 - x_2)} \\\\ \\\\\n\\implies P_3(2.25) =&\n0.5403 \\times\\frac{(2.25 - 0)(2.25 - 2)(2.25 - 2.5)}{(-1-0)(-1-2)(-1-2.5)}  \\\\ \\\\\n&+ 1\\times\\frac{(2.25 +1)(2.25 - 2)(2.25 - 2.5)}{(0+1)(0-2)(0-2.5)}  \\\\ \\\\\n&-0.4162\\times\\frac{(2.25 +1)(2.25 - 0)(2.25 - 2.5)}{(2+1)(2-0)(2-2.5)}  \\\\ \\\\\n&-0.8011 \\times\\frac{(2.25 +1)(2.25 - 0)(2.25 - 2)}{(2.5+1)(2.5-0)(2.5-2)}  = \\\\ \\\\\n&= -0.6217561 \\\\ \\\\\n&\\therefore f(2.25) \\approx -0.6217561\n\\end{split}\n\\]\n\nLa fórmula fue programada en la función provista lagrange():\n\n\nx = np.array([-1, 0, 2, 2.5])\nfx = np.array([0.5403, 1, -0.4162, -0.8011])\nlagrange(x, fx, 2.25)\n\n-0.6217560714285715\n\n\n\nSi en la fórmula anterior en lugar de reemplazar \\(x\\) por un valor particular (en este caso, \\(2.25\\)) operamos y re acomodamos los términos, podemos hallar la expresión del polinomio interpolante:\n\\[\n  P_3(x) = 0.1042 x^3 -0.4934 x^2 -0.1379 x+1\n  \\]\nPodemos graficar este polinomio para ver lo que ha logrado este método:\n\n\n# Definir la función p3 como una función lambda\np3 = lambda x: 0.1042 * x**3 - 0.4934 * x**2 - 0.1379 * x + 1\n\n# Crear un rango de valores para x\nrango_x = np.linspace(-1.2, 2.7, 100)\n\n# Calcular los valores correspondientes de p3\ny = p3(rango_x)\n\n# Crear el gráfico\nplt.figure(figsize=(8, 6))\nplt.grid(True)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.plot(rango_x, y, label=\"Polinomio interpolante\", color='blue')\nplt.legend()\nplt.show()\n\n\n\n\n\nEn Python podemos usar la función polyfit() de la librería numpy.polynomial.polynomial para obtener la expresión del polinomio interpolante de Lagrange y realizar interpolaciones, pero como siempre escribimmos nuestras propias funciones para entender lo que hacen los métodos y repasar programación:\n\n\n# Ajustar un polinomio a los datos\nx = np.array([-1, 0, 2, 2.5])\nfx = np.array([0.5403, 1, -0.4162, -0.8011])\n\n# Coeficientes del polinomio (menor a mayor grado)\ncoefs = npol.polyfit(x, fx, deg = len(x) - 1)\nprint(coefs)\n\n[ 1.         -0.1379019  -0.49343429  0.10416762]\n\n# Convertir esos coeficientes en una función polinómica\npoli = npol.Polynomial(coefs)\n# Mostrar la expresion del polinomio\nprint(poli)\n\n1.0 - 0.1379019·x - 0.49343429·x² + 0.10416762·x³\n\n# Evaluar el polinomio interpolante en el punto 2.25\npoli(2.25)\n\n-0.6217560714285701\n\n\n\nLa verdadera función que generó los valores tabulados es \\(cos(x)\\). Podemos compararla con el polinomio interpolante:\n\n\ny_cos = np.cos(rango_x)\n\nplt.figure(figsize=(8, 6))\nplt.grid(True)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.plot(rango_x, y, label=\"Polinomio interpolante\", color='blue')\nplt.plot(rango_x, y_cos, label=\"Coseno\", color='green')\nplt.legend()\nplt.show()\n\n\n\n\n\nOjo, si nos alejamos del rango estudiado, el polinomio no tiene por qué aproximar bien (cuidado con la extrapolación)…\n\n\n# Función verdadera (coseno) y polinimo interpolante fuera del rango de puntos\n# disponibles\nrango_x = np.linspace(-5, 8, 100)\ny_cos = np.cos(rango_x)\ny = p3(rango_x)\n\nplt.figure(figsize=(8, 6))\nplt.grid(True)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.plot(rango_x, y, label=\"Polinomio interpolante\", color='blue')\nplt.plot(rango_x, y_cos, label=\"Coseno\", color='green')\nplt.ylim(-6, 6)\n\n(-6.0, 6.0)\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n1.2.3 Error de aproximación\n\nEn el ejemplo, sabiendo el verdadero valor \\(cos(2.25) = -0.6281736\\), podemos calcular el error absoluto:\n\\[|-0.6281736+0.6217561| = 0.0064175\\]\ny el error relativo:\n\\[\\frac{|-0.6281736+0.6217561|}{|-0.6281736|} = 1.021612\\%\\]\nEn una situación práctica donde no tenemos el verdadero \\(f(x)\\), vale el siguiente resultado.\nSe puede demostrar (ver opcionalemente Teorema 3.3) que el error en la aproximación con el polinomio de Lagrange está dado por:\n\\[\nf(x) - P_n(x) = \\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)(x-x_1)...(x-x_n)\n\\]\ndonde \\(\\xi\\) es algún número dentro del intervalo en el que se encuentran los nodos \\(x_i\\).\n\n\nPara saber cuál es la cota superior del error se busca acotar la expresión anterior para cualquier \\(\\xi\\) dentro del rango estudiado (ver opcionalmente ejemplos 3 y 4).\nEn el ejemplo nuestro, siendo \\(f(x) = cos(x)\\), \\(n=3\\) y \\(f^{(4)}(x) = cos(x)\\):\n\\[\nf(x) - P_n(x) = \\frac{cos(\\xi)}{4!}(x+1)x(x-2)(x-2.5) \\qquad -1 \\leq \\xi \\leq 2.5\n\\]\nSabiendo que \\(|cos(\\xi)| \\leq 1\\), encontramos una cota superior para el error de aproximación:\n\\[\n|f(x) - P_n(x)| \\leq \\Big|\\frac{1}{4!}(x+1)x(x-2)(x-2.5)\\Big|\n\\]\nPara el punto analizado \\(x=2.25\\) esa cota superior nos da \\(0.01904297\\) (y efectivamente el error absoluto, que lo pudimos calcular, era menor que esto).\nEste resultado es muy importante porque permite evaluar el desempeño de la aproximación pero muchas veces es impracticable porque no se conoce cuál es la derivada \\(f^{(n+1)}\\), por lo tanto tiene utilidad teórica pero no práctica.\nEn esos casos, sólo es posible evaluar la precisión al comparar las aproximaciones obtenidas con polinomios de distinto grado (ver ejemplo en la sección “Ilustración” en páginas 86 y 87).\n\n\n\n\n\n\n1.2.4 Ventajas y desventajas\n\nVentajas:\n\nUna ventaja de este método de Lagrange es que provee de una forma sencilla una expresión explícita para el polinomio de interpolación.\nAdemás, no requiere que los puntos \\(x_i\\) estén ordenados ni sean equiespaciados.\n\nDesventaja:\n\nDado que el término de error difícilmente puede ser construído, generalmente se necesitan considerar varios polinomios de interpolación de distinto grado para comparar las aproximaciones logradas.\nSin embargo, con el método de Lagrange no hay relación entre la construcción de un polinomio de un grado \\(n\\) y otro de grado \\(n+1\\); cada polinomio debe construirse individualmente realizando todos los cálculos otra vez, lo cual resulta laborioso y poco eficiente.\n\nEl Método de Neville (no lo estudiaremos) soluciona este inconveniente, reformulando los cálculos para poder obtener aproximaciones usando cálculos previos. Una aproximación de grado \\(n+1\\) se logra tomando la de grado \\(n\\) y sumándole otro término.\nSin embargo, este método no permite obtener una expresión explícita del polinomio.\nPara poder generar sucesivamente los polinomios interpolantes se puede recurrir a los métodos de diferencias de Newton que se presentan en la siguiente sección.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aproximación polinomial - Parte 1: interpolación</span>"
    ]
  },
  {
    "objectID": "06_aprox_polin_parte1.html#polinomios-de-interpolación-de-newton",
    "href": "06_aprox_polin_parte1.html#polinomios-de-interpolación-de-newton",
    "title": "1  Aproximación polinomial - Parte 1: interpolación",
    "section": "1.3 Polinomios de interpolación de Newton",
    "text": "1.3 Polinomios de interpolación de Newton\n\nA pesar de que el polinomio que \\(P_n(x)\\) que concuerda con la función \\(f\\) en \\(x_0, ..., x_n\\) es único, existen diferentes representaciones algebraicas que son útiles en distintas situaciones y la fórmula de Lagrange es sólo una de ellas.\nPara poder generer polinomios interpolantes con otra expresión que admita cálculos recursivos (es decir, aprovechando los cálculos hechos para polinomios de menor grado), vamos a necesitar obtener una tabla de diferencias divididas y una tabla de diferencias ordinarias.\n\n\n1.3.1 Diferencias divididas\n\nPresentar formalmente a las diferencias divididas es más difícil que calcularlas.\n\n\nDefinición:\n\nLa cero-ésima diferencia dividida de la función \\(f\\) respecto a \\(x_i\\) es: \\(f[x_i] = f(x_i)\\).\nLa primera diferencia dividida de \\(f\\) respecto a \\(x_i\\) y \\(x_{i+1}\\) es:\n\\[\n  f[x_i, x_{i+1}] = \\frac{f[x_{i+1}] - f[x_i]}{x_{i+1} - x_i}\n  \\]\nLa segunda diferencia dividida de \\(f\\) respecto a \\(x_i\\), \\(x_{i+1}\\) y \\(x_{i+2}\\) es:\n\\[\n  f[x_i, x_{i+1}, x_{i+2}] = \\frac{f[x_{i+1},x_{i+2}] - f[x_{i},x_{i+1}]}{x_{i+2} - x_i}\n  \\]\nDe manera general, después de haber calculado las \\(k-1\\) diferencias divididas:\n\\[\n  f[x_i, ..., x_{i+k-1}] \\quad \\text{ y } \\quad f[x_{i+1}, ..., x_{i+k}],\n  \\]\nla \\(k\\)-ésima diferencia dividida relativa a \\(x_i, ..., x_{i+k}\\) es:\n\\[\n  f[x_i, ..., x_{i+k}] = \\frac{f[x_{i+1}, ..., x_{i+k}] - f[x_i, ..., x_{i+k-1}]}{x_{i+k} - x_i}\n  \\]\n\n\n\n\nLo anterior es más claro si lo presentamos en una tabla de diferencias divididas.\nPor ejemplo, con 6 puntos:\n\n\n\n\n\n\n\nLa tabla anterior podría llegar hasta las quintas diferencias divididas.\nEn general, si contamos con \\(n+1\\) puntos, podemos calcular hasta las diferencias divididas de orden \\(n\\).\n\n\n\n1.3.2 Fórmula general de Newton para la interpolación con diferencias divididas\n\nPara poder generar polinomios interpolantes de distinto orden recursivamente Newton propone emplear la siguiente representación para \\(P_n(x)\\):\n\n\\[\\begin{equation}\n\\label{eq:eq1}\nP_n(x) = a_0 + a_1 (x - x_0) + a_2 (x-x_0)(x-x_1)+...+a_n(x-x_0)...(x-x_{n-1})\n\\end{equation}\\]\n\nDe hecho, antes repasamos la fórmula de la recta (polinomio interpolante de grado 1) que pasa por dos puntos y estaba escrita de esa forma:\n\\[\n  P_1(x) = \\underbrace{f(x_0)}_{a_0} + \\underbrace{\\frac{f(x_1) - f(x_0)}{x_1 - x_0}}_{a_1} (x - x_0)\n  \\]\nSi miramos bien, tenemos que notar que \\(a_0\\) y \\(a_1\\) coinciden con la definición de diferencias divididas para \\(x_0\\) de orden 0 y 1, respectivamente.\nDe manera general, se puede probar que las constantes \\(a_k\\) necesarias para expresar \\(P_n(x)\\) de la forma deseada \\(\\eqref{eq:eq1}\\) son las diferencias divididas \\(a_k = f[x_0, ...,x_k]\\), haciendo que el polinomio quede así:\n\\[\\begin{equation}\n  \\label{eq:eq2}\n  P_n(x) = f[x_0] + \\sum_{k=1}^{n} f[x_0,..., x_k] (x-x_0)...(x-x_{k-1})\n\\end{equation}\\]\nEs decir, se usan las diferencias divididas que están en la diagonal de la tabla.\nEjemplo. Retomamos el ejemplo anterior. A continuación se presentan los puntos tabulados junto con las diferencias divididas. Los valores en negrita son los que se utilizan en la fórmula. Verificar los cálculos a mano.\n\n\n\n\n\n\n\n\n\n\n\ni\n\\(x_i\\)\n\\(f(x_i)\\)\nPrimeras diferencias\nSegundas diferencias\nTerceras diferencias\n\n\n\n\n0\n-1\n0.5403\n\n\n\n\n\n\n\n\n0.4597\n\n\n\n\n1\n0\n1.0000\n\n-0.3893\n\n\n\n\n\n\n-0.7081\n\n0.1042\n\n\n2\n2\n-0.4162\n\n-0.0247\n\n\n\n\n\n\n-0.7698\n\n\n\n\n3\n2.5\n-0.8011\n\n\n\n\n\n\nEn Python vamos a usar la función provista diferencias() para obtener este resultado:\n\n\ndiferencias(fx, x)\n\narray([[ 0.5403    ,  0.4597    , -0.38926667,  0.10416762],\n       [ 1.        , -0.7081    , -0.02468   ,         nan],\n       [-0.4162    , -0.7698    ,         nan,         nan],\n       [-0.8011    ,         nan,         nan,         nan]])\n\n\n\nVamos emplear el método de las diferencias divididas de Newton para interpolar el valor de la función \\(f\\) en \\(x=2.25\\), con el polinomio interpolante de grado 3 que pasa por los cuatro puntos tabulados:\n\\[\n  \\begin{split}\n  P_3(x) &= f[x_0] + \\sum_{k=1}^{3} f[x_0,..., x_k] (x-x_0)...(x-x_{k-1}) \\\\\\\\\n  &= 0.5403 \\\\\\\\\n  &+ 0.4597 (x+1) \\\\\\\\\n  &- 0.3893 (x+1)x \\\\\\\\\n  &+ 0.1042 (x+1)x(x-2) \\\\\\\\\n  \\implies P_3(2.25) &= -0.6217561\n  \\end{split}\n  \\]\nEn Python lo vamos a aplicar en la función newton_general() (provista en el archivo de funciones):\n\n\nnewton_general(x, fx, valor = 2.25)\n\n-0.6217560714285713\n\n\n\nComo el polinomio de grado 3 que pasa por 4 puntos es único, este resultado coincide con el del método de Lagrange.\nSin embargo, tiene una ventaja importante. No siempre es necesario ni conveniente ajustar el polinomio de mayor orden posible, pero probar con distintos grados es muy laborioso en el método de Lagrange.\nEn cambio este método lo vuelve más sencillo, porque pasamos de una aproximación de un grado menor a otra de un grado superior solamente sumando un término más en la cuenta. Se aprovechan los cálculos anteriores. Entonces:\n\n\n\n\n\n\n\n\nGrado\n\\(P_n(2.25) =\\)\n\n\n\n\n1\n\\(f[x_0] + f[x_0, x_1] (x-x_0) = 2.0343\\)\n\n\n2\n\\(2.0343 + f[x_0, x_1, x_2] (x-x_0)(x-x_1) = -0.8124\\)\n\n\n3\n\\(-0.8124 + f[x_0, x_1, x_2, x_3] (x-x_0)(x-x_1)(x-x_3) = -0.6218\\)\n\n\n\n\nEn Python:\n\n\nfor grado in range(1, 4):\n  print(newton_general(x, fx, valor = 2.25, g = grado))\n\n2.034325\n-0.8121874999999998\n-0.6217560714285713\n\n\n\nLa primera aproximación es una interpolación lineal y pasa por los primeros dos puntos; la segunda es cuadrática y pasa por los primeros tres puntos y la última es cúbica y pasa por todos los puntos:\n\n\n\n\n\n\n\nEs claro que la aproximación lineal anterior no es buena para \\(x=2.25\\).\nSin embargo, una recta que pase por los últimos dos puntos podría tener un desempeño similar al del polinomio de grado 3:\n\n\nnewton_general(x[2:], fx[2:], 2.25)\n\n-0.60865\n\n\n\n# preparar curvas para graficar\np1b = npol.Polynomial(npol.polyfit(x[2:], fx[2:], deg = 1))\ny_p1b = p1b(rango_x)\n\n# Crear el gráfico\nplt.figure(figsize=(8, 6))\nplt.grid(True)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.plot(rango_x, y_p1, label=\"Con x0 = -1\", color='red')\nplt.plot(rango_x, y_p1b, label=\"Con x0 = 2\", color='green')\nplt.legend()\nplt.title(\"Polinomios interpolantes de grado 1\")\nplt.axvline(x=2.25, linestyle='--')\nplt.scatter([2.25, 2.25], [p1(2.25), p1b(2.25)], color = \"orange\", s = 100)\nplt.show()\n\n\n\n\n\nLa expresión anterior facilita la obtención de polinomios interpolantes de diferentes grados, puesto que los mismos sólo se diferencian en términos que se van agregando en la parte de la sumatoria.\nSin embargo, la expresión de la fórmula no deja de ser algo compleja e involucra muchos cálculos.\nEn el caso de que los nodos \\(x_i\\) están ordenados de menor a mayor y tengan igual espaciado entre ellos, la fórmula se simplifica muchísimo y recibe el nombre de\nPero para conocer esta fórmula necesitamos definir las diferencias ordinarias.\n\n\n\n1.3.3 Diferencias ordinarias\n\nLas diferencias ordinarias se asemejan a las divididas, pero no hacen la división por las restas entre valores de \\(x\\).\n\n\nDefinición: las diferencias ordinarias se expresan como:\n\\[\n\\Delta^{j} f(x_k) = \\Delta^{j-1} f(x_{k+1}) - \\Delta^{j-1} f(x_k)\n\\qquad\nj = 1, ..., n \\qquad k = 0, ..., j-1 \\qquad \\Delta^{0} f(x_k) = f(x_k)\n\\]\n\n\nEs decir que las diferencias de orden 0 son los mismos valores \\(f(x_i)\\), las diferencias de orden 1 son \\(f(x_{k+1}) - f(x_k)\\), las diferencias de orden 2 son restas con las de orden 1, y así sucesivamente.\nPara simplificar la notación, cuando no haya ambigüedad vamos a escribir: \\(\\Delta^{j} f(x_k) = \\Delta^j_k\\).\nLa tabla de diferencias ordinarias es:\n\n\n\n\n\n\n\n\nEn general, si contamos con \\(n+1\\) puntos, podemos calcular hasta las diferencias ordinarias de orden \\(n\\).\n\n\n\n1.3.4 Fórmula de interpolación de Newton con diferencias hacia adelante\n\nVeamos cómo la fórmula general de Newton se simplifica para el caso particular en el que los nodos \\(x_i\\) están ordenados de menor a mayor y son equiespaciados.\nLlamamos con \\(h\\) al espaciado uniforme: \\(h = x_{i+1}-x_i\\), para cada \\(i=0, 1, ..., n-1\\).\nCualquier valor \\(x\\) puede ser expresado como \\(x = x_0 + sh\\) y en particular los nodos se pueden escribir como \\(x_i = x_0 + ih\\).\nEntonces nos queda: \\(x - x_i = (s-i)h\\).\nHaciendo los reemplazos correspondientes y después de varios pasos algebraicos, \\(\\eqref{eq:eq2}\\) nos queda de una forma mucho más compacta:\n\\[\n\\begin{aligned}\nP_n(x)\n&= f(x_0) + s \\Delta^1_0 + \\frac{s(s-1)}{2!} \\Delta^2_0 + \\frac{s(s-1)(s-2)}{3!} \\Delta^3_0 + ...\\\\\n&= \\sum_{k=0}^n {s \\choose k} \\Delta_0^k\n\\end{aligned}\n\\]\ndonde: \\({s \\choose k} = \\frac{s(s-1)(s-2)...(s-k+1)}{k!}\\).\nEsta es la fórmula de interpolación de Newton con diferencias hacia adelante, porque utiliza la primera diagonal desde arriba a la izquierda hacia abajo a la derecha de la tabla de diferencias ordinarias.\nHay que observar que la fórmula empieza con el valor de \\(f(x_0)\\) y luego continúa empleando las diferencias \\(\\Delta_0^k\\).\n\nEjemplo.\n\nSea \\(f(x)\\) una función desconocida de la cual se tienen los valores tabulados \\((x_i, f(x_i))\\) que se presentan a continuación, junto con una representación gráfica de los mismos:\n\n\n\n\n\\(i\\)\n\\(x_i\\)\n\\(f(x_i)\\)\n\n\n\n\n0\n2\n0.3010\n\n\n1\n3\n0.4771\n\n\n2\n4\n0.6021\n\n\n3\n5\n0.6990\n\n\n4\n6\n0.7781\n\n\n5\n7\n0.8451\n\n\n\n\n# Crear un DataFrame con los datos\ndatos = pd.DataFrame({'x': range(2, 8), 'y': [0.3010, 0.4771, 0.6021, 0.6990, 0.7781, 0.8451]})\n\n# Crear el gráfico\nplt.figure()\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.xlim(-0.2, 8)\n\n(-0.2, 8.0)\n\nplt.grid(True)\nplt.show()\n\n\n\n\n\nLa correspondiente tabla de diferencias ordinarias es (verificar los cálculos a mano):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(i\\)\n\\(x_i\\)\n\\(f(x_i)\\)\n\\(\\Delta^1_i\\)\n\\(\\Delta^2_i\\)\n\\(\\Delta^3_i\\)\n\\(\\Delta^4_i\\)\n\\(\\Delta^5_i\\)\n\n\n\n\n0\n2\n0.3010\n\n\n\n\n\n\n\n\n\n\n0.1761\n\n\n\n\n\n\n1\n3\n0.4771\n\n-0.0511\n\n\n\n\n\n\n\n\n0.1250\n\n0.0230\n\n\n\n\n2\n4\n0.6021\n\n-0.0281\n\n-0.0127\n\n\n\n\n\n\n0.0969\n\n0.0103\n\n0.0081\n\n\n3\n5\n0.6990\n\n-0.0178\n\n-0.0046\n\n\n\n\n\n\n0.0791\n\n0.0057\n\n\n\n\n4\n6\n0.7781\n\n-0.0121\n\n\n\n\n\n\n\n\n0.0670\n\n\n\n\n\n\n5\n7\n0.8451\n\n\n\n\n\n\n\n\n\n\nLos valores en negrita son los que utiliza la fórmula.\nTambién usamos la función diferencias() para obtenerla, que devuelve las diferencias ordinarias si no se provee un vector de \\(x_i\\):\n\n\nfx = np.array([.3010, .4771, .6021, .6990, .7781, .8451])\ndiferencias(fx)\n\narray([[ 0.301 ,  0.1761, -0.0511,  0.023 , -0.0127,  0.0081],\n       [ 0.4771,  0.125 , -0.0281,  0.0103, -0.0046,     nan],\n       [ 0.6021,  0.0969, -0.0178,  0.0057,     nan,     nan],\n       [ 0.699 ,  0.0791, -0.0121,     nan,     nan,     nan],\n       [ 0.7781,  0.067 ,     nan,     nan,     nan,     nan],\n       [ 0.8451,     nan,     nan,     nan,     nan,     nan]])\n\n\n\nVamos a aproximar \\(f(2.3)\\) con un polinomio de grado 5 que pase por todos los puntos provistos:\n\n\\(h = 1\\) (espaciado)\n\\(x=2.3\\)\n\\(x_0 = 2\\)\n\\(s = \\frac{x-x_0}{h} = \\frac{2.3-2}{1} = 0.3\\)\n\n\\[\n\\begin{aligned}\nP_5(x)\n&= \\sum_{k=0}^5 {s \\choose k} \\Delta_0^k \\\\ \\\\\n&= f(x_0) + s \\Delta^1_0 + \\frac{s(s-1)}{2!} \\Delta^2_0 + \\frac{s(s-1)(s-2)}{3!} \\Delta^3_0 + ...\\\\ \\\\\n&= 0.3010 \\\\\\\\\n&+ 0.3 \\times 0.1761 \\\\ \\\\\n&+ \\frac{0.3(0.3-1)}{2!} (-0.0511) \\\\ \\\\\n&+ \\frac{0.3(0.3-1)(0.3-2)}{3!} 0.0230 \\\\ \\\\\n&+ \\frac{0.3(0.3-1)(0.3-2)(0.3-3)}{4!} (-0.0127) \\\\ \\\\\n&+ \\frac{0.3(0.3-1)(0.3-2)(0.3-3)(0.3-4)}{5!} 0.0081 \\\\ \\\\\n\\implies P_5(2.3) &= 0.3613\n\\end{aligned}\n\\]\nEn Python vamos a usar la función newton_adelante() (provista):\n\n\nnewton_adelante(fx, s = 0.3)\n\n0.36131479777500003\n\n\n\nSi en la fórmula anterior reemplazamos \\(s\\) por su defición \\((x - 2)/1\\) y con mucha paciencia operamos en términos de \\(x\\), podemos encontrar una expresión explícita para el polinomio.\nComo vimos antes, en Python lo hacemos con:\n\n\nx = np.arange(2, 8)\nfx = np.array([.3010, .4771, .6021, .6990, .7781, .8451])\n\n# Coeficientes del polinomio (menor a mayor grado)\ncoefs_g5 = npol.polyfit(x, fx, deg = len(x) - 1)\nprint(coefs)\n\n[ 1.         -0.1379019  -0.49343429  0.10416762]\n\n# Convertir esos coeficientes en una función polinómica\npoli_g5 = npol.Polynomial(coefs_g5)\n# Mostrar la expresion del polinomio\nprint(poli_g5)\n\n-0.4086 + 0.55547833·x - 0.13677083·x² + 0.02170417·x³ - 0.00187917·x⁴ +\n(6.75e-05)·x⁵\n\n# Evaluar el polinomio interpolante en el punto 2.3\npoli_g5(2.3)\n\n0.3613147977750001\n\n\n\nLuego, lo podemos graficar:\n\n\n# Crear un rango de valores para x\nrango_x = np.linspace(2, 7, 100)\n\n# Calcular los valores correspondientes\ny_g5 = poli_g5(rango_x)\n\n# Crear el gráfico\nplt.figure()\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.xlim(-0.2, 8)\n\n(-0.2, 8.0)\n\nplt.grid(True)\nplt.plot(rango_x, y_g5, color='blue')\nplt.title(\"Polinomio interpolante de grado 5\")\nplt.scatter(2.3, poli_g5(2.3), color = \"orange\", s = 100)\nplt.axvline(x=2.3, linestyle='--')\nplt.show()\n\n\n\n\n\nComo el polinomio de grado 5 que pasa por 6 puntos es único, la expresión hallada coincide a la que se hubiese obtenido con la fórmula general de Newton o con la de Lagrange.\n¿Es necesario haber empleado un polinomio de grado 5?\nViendo el gráfico podemos pensar que una función cuadrática puede proveer un buen ajuste.\nEso tiene la ventaja de ahorrar cálculos y evita acumular errores por redondeo.\nPor eso, podríamos haber propuesto inicialmente un polinomio interpolante de grado 2, que pasa por los primeros 3 puntos, usando hasta la diferencia de segundo orden:\n\n\\(h = 1\\) (espaciado)\n\\(x=2.3\\)\n\\(x_0 = 2\\)\n\\(s = \\frac{x-x_0}{h} = \\frac{2.3-2}{1} = 0.3\\)\n\n\\[\n\\begin{aligned}\nP_2(x)\n&= \\sum_{k=0}^2 {s \\choose k} \\Delta_0^k \\\\ \\\\\n&= f(x_0) + s \\Delta^1_0 + \\frac{s(s-1)}{2!} \\Delta^2_0 \\\\ \\\\\n&= 0.3010 + 0.3 \\times 0.1761 + \\frac{0.3(0.3-1)}{2!} (-0.0511) \\\\ \\\\\n\\implies P_2(2.3) &= 0.3592\n\\end{aligned}\n\\]\n\n\n# Polinomio interpolante de grado 2 que pasa por los primeros 3 ptos\npoli_g2 = npol.Polynomial(npol.polyfit(x[:3], fx[:3], deg = 2))\n\n# Mostrar la expresion del polinomio\nprint(poli_g2)\n\n-0.2045 + 0.30385·x - 0.02555·x²\n\n# Evaluar el polinomio interpolante en el punto 2.3\npoli_g2(2.3)\n\n0.35919549999999956\n\n# Graficarlo\ny_g2 = poli_g2(rango_x)\nplt.figure()\nplt.scatter(datos['x'], datos['y'], color='red', s=100)\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.xlim(-0.2, 8)\n\n(-0.2, 8.0)\n\nplt.grid(True)\nplt.plot(rango_x, y_g2, color='blue')\nplt.title(\"Polinomio interpolante de grado 2 con x0 = 2\")\nplt.scatter(2.3, poli_g2(2.3), color = \"orange\", s = 100)\nplt.axvline(x=2.3, linestyle='--')\nplt.show()\n\n\n\n\n\nObservación: es claro que no podemos esperar que este polinomio provea aproximaciones razonables para \\(x\\) cercano al final del rango.\nLo bueno de este método, a diferencia del del Lagrange y al igual que la fórmula general, es que permite empezar por una interpolación de grado 1 e ir generado las aproximaciones de grado superior al agregar de a uno los términos siguientes, aprovechando los cálculos anteriores:\n\n\n\n\n\n\n\n\nGrado\n\\(P_n(2.3) =\\)\n\n\n\n\n1\n\\(f(x_0) + s \\Delta^1_0 = 0.3538\\)\n\n\n2\n\\(0.3538 + \\frac{s(s-1)}{2!}\\Delta^2_0 = 0.3592\\)\n\n\n3\n\\(0.3592 + \\frac{s(s-1)(s-2)}{3!}\\Delta^3_0 = 0.3606\\)\n\n\n4\n\\(0.3606 + \\frac{s(s-1)(s-2)(s-3)}{4!}\\Delta^4_0 = 0.3611\\)\n\n\n5\n\\(0.3611 + \\frac{s(s-1)(s-2)(s-3)(s-4)}{5!}\\Delta^5_0 = 0.3613\\)\n\n\n\n\nEn Python:\n\n\nfor grado in range(1, 6):\n  print(newton_adelante(fx, s = 0.3, g = grado))\n\n0.35383\n0.3591955\n0.360564\n0.36107406375\n0.36131479777500003\n\n\n\nLa primera aproximación es una interpolación lineal y pasa por los primeros dos puntos; la segunda es cuadrática y pasa por los primeros tres puntos, etc.\n\n\n\n(-0.2, 8.0)\n\n\n(-0.05, 1.0)\n\n\n\n\n\n\nLa función que generó la tabla de este ejemplo es el logaritmo en base 10, es decir, que el valor exacto es \\(f(2.3) = log(2.3) = 0.3617\\).\nCon esta información, podemos calcular el Error Relativo que resulta de hacer las aproximaciones anteriores:\n\n\n\n\nGrado\n\\(P_n(2.3) =\\)\nER\n\n\n\n\n1\n0.3538\n0.0218\n\n\n2\n0.3592\n0.0070\n\n\n3\n0.3606\n0.0032\n\n\n4\n0.3611\n0.0018\n\n\n5\n0.3613\n0.0012\n\n\n\n\n\n1.3.5 Otras fórmulas de interpolación de Newton\n\nAsí como dijimos que cualquier valor \\(x\\) puede ser expresado como \\(x = x_0 + sh\\), también podemos decir que cualquier valor \\(x\\) puede ser expresado como \\(x = x_n +sh\\) con \\(s\\) negativo y los nodos se pueden escribir como \\(x_i = x_n - (n-i)h\\).\nTeniendo en cuenta esto y haciendo varios reemplazos y pasos, el polinomio \\(\\eqref{eq:eq2}\\) queda así:\n\\[\n  \\begin{aligned}\n  P_n(x)\n  &= f(x_n) - (-s) \\Delta^1_{n-1} + \\frac{-s(-s-1)}{2!} \\Delta^2_{n-2} - \\frac{-s(-s-1)(-s-2)}{3!} \\Delta^3_{n-3} + ...\\\\\n  &= \\sum_{k=0}^n (-1)^k {-s \\choose k} \\Delta_{n-k}^k\n  \\end{aligned}\n  \\]\nEsta es la fórmula de interpolación de Newton con diferencias hacia atrás, porque utiliza la última diagonal desde abajo a la izquierda hacia arriba a la derecha de la tabla de diferencias ordinarias.\nHay que observar que la fórmula empieza con el valor de \\(f(x_n)\\) y luego continúa empleando la última diferencia de cada orden.\nNo realizaremos ejemplos con esta forma de interpolación.\nSin embargo, al tener dos fórmulas de diferencias ordinarias para hacer interpolaciones, cabe preguntarse: ¿en qué se diferencian? ¿Cuál usar?\nAmbas fórmulas son expresiones diferentes del mismo polinomio de grado \\(n\\), por lo tanto, es lo mismo usar una u otra.\nNo obstante, sus resultados pueden diferir por causa de los errores de redondeo propios de la aritmética finita con la que se realizan los tantísimos cálculos que hay que hacer y que son distintos en una y otra fórmula.\nSi tenemos que interpolar para un \\(x\\) cercano al comienzo de la tabla (es decir, más bien cerca de \\(x_0\\)), conviene utilizar la fórmula hacia adelante. La misma empieza usando \\(f(x_0)\\), y estando \\(x\\) cerca de \\(x_0\\), es de esperar que \\(f(x_0)\\) esté cerca de \\(f(x)\\), por lo cual es un buen punto de partida.\nEn cambio, si tenemos que interpolar para un \\(x\\) cercano al final de la tabla, por la misma razón conviene utilizar la fórmula hacia atrás.\nAtención: si en lugar de usar las fórmulas completas, empleamos menos términos para interpolar con polinomios de menor grado (es decir, que pasen por algunos pero no todos los \\(x_i\\)), entonces los polinomios que resulten de una u otra fórmula ya no serán equivalentes (porque la fórmula hacia adelante usará los primeros puntos tabulados, mientras que la fórmula hacia atrás usará los últimos).\n¿Y si el valor de \\(x\\) está más bien cerca de mitad de tabla?…\nLas fórmulas de diferencias hacia adelante y hacia atrás de Newton no son adecuadas para aproximar \\(f(x)\\) cuando \\(x\\) se encuentra cerca del centro de la tabla.\nExisten varias fórmulas de diferencias divididas para este caso, cada una más ventajosa que otras para distintas situaciones.\nEstos métodos reciben el nombre de fórmulas de diferencias centradas.\nUno de ellos se conoce como fórmula de Stirling.\nLa fórmula considera que \\(x_0\\) es el nodo central y entonces hay que “cambiarle el nombre” a los valores de la tabla de diferencias ordinarias (pero son los mismos):\n\n\n\n\n\n\n\n\nEl polinomio de Stirling usa las diferencias que están pintadas, pero no consideraremos su fórmula.\nEn resumen, la siguiente tabla de diferencias ordinarias tiene indicadas cuáles son las que se usan en un polinomio de interpolación con las fórmulas de diferencias hacia adelante, hacia atrás y centradas.\nSi se construye un polinomio de grado \\(n\\), los tres polinomios son el mismo.\nDependiendo de dónde se encuentre el punto \\(x\\) a interpolar, conviene usar una u otra para disminuir errores de redondeo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aproximación polinomial - Parte 1: interpolación</span>"
    ]
  },
  {
    "objectID": "06_aprox_polin_parte1.html#observaciones-finales",
    "href": "06_aprox_polin_parte1.html#observaciones-finales",
    "title": "1  Aproximación polinomial - Parte 1: interpolación",
    "section": "1.4 Observaciones finales",
    "text": "1.4 Observaciones finales\n\nUn polinomio de grado \\(n\\) ajustado a \\(n+1\\) puntos es único.\nEl polinomio de interpolación se puede expresar en varias formas distintas, pero todas son equivalentes por el punto anterior.\nSi tenemos \\(n+1\\) puntos podemos calcular \\(n\\) columnas de diferencias hacia adelante.\nSi la función \\(f(x)\\) que dio lugar a la tabla es un polinomio de orden \\(q\\), entonces la columna para la diferencia de orden \\(q\\) es constante y las siguientes columnas son todas nulas.\nPor lo tanto, si en el proceso de obtención de las diferencias sucesivas de una función, las diferencias de orden \\(q\\) se vuelven constantes (o aproximadamente constantes), sabemos que los datos provienen exactamente (o muy aproximadamente) de un polinomio de orden \\(q\\).\nErrores de redondeo podrían hacer que a pesar de que los datos provengan de un polinomio, no encontremos diferencias constantes.\nSi una función se aproxima mediante un polinomio de interpolación, no hay garantía de que dicho polinomio converja a la función exacta al aumentar el número de datos. En general, la interpolación mediante un polinomio de orden grande debe evitarse o utilizarse con precauciones extremas.\nEso se debe a que los polinomios de orden superior pueden oscilar erráticamente; es decir, una fluctuación menor sobre una pequeña parte del intervalo puede inducir fluctuaciones grandes sobre todo el rango (ver ejemplo en la figura 3.14).\nAunque no existe un criterio para determinar el orden óptimo del polinomio de interpolación, generalmente se recomienda utilizar uno con orden relativamente bajo en un pequeño rango de \\(x\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Aproximación polinomial - Parte 1: interpolación</span>"
    ]
  }
]