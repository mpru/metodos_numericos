<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.467">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Métodos Numéricos con Python - 2&nbsp; Resolución de ecuaciones en una variable</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./03_sistemas_lineales.html" rel="next">
<link href="./01_intro.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./02_ecuaciones.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Resolución de ecuaciones en una variable</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Métodos Numéricos con Python</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/mpru/metodos_numericos/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Métodos-Numéricos-con-Python.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Conceptos básicos de análisis numérico</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_ecuaciones.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Resolución de ecuaciones en una variable</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_sistemas_lineales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Resolución de sistemas de ecuaciones lineales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_sistemasnolineales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Resolución de sistemas de ecuaciones no lineales y optimización</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_autovalores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Valores y vectores propios</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_aprox_polin_parte1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Aproximación polinomial - Parte 1: interpolación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_aprox_polin_parte2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Aproximación polinomial - Parte 2: Derivación e integración</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción"><span class="header-section-number">2.1</span> Introducción</a></li>
  <li><a href="#el-método-de-la-bisección-o-búsqueda-binaria" id="toc-el-método-de-la-bisección-o-búsqueda-binaria" class="nav-link" data-scroll-target="#el-método-de-la-bisección-o-búsqueda-binaria"><span class="header-section-number">2.2</span> El método de la bisección o búsqueda binaria</a></li>
  <li><a href="#el-método-del-punto-fijo-o-de-las-aproximaciones-sucesivas" id="toc-el-método-del-punto-fijo-o-de-las-aproximaciones-sucesivas" class="nav-link" data-scroll-target="#el-método-del-punto-fijo-o-de-las-aproximaciones-sucesivas"><span class="header-section-number">2.3</span> El método del punto fijo o de las aproximaciones sucesivas</a>
  <ul class="collapse">
  <li><a href="#punto-fijo" id="toc-punto-fijo" class="nav-link" data-scroll-target="#punto-fijo"><span class="header-section-number">2.3.1</span> Punto fijo</a></li>
  <li><a href="#uso-de-la-iteración-de-punto-fijo-para-resolver-ecuaciones" id="toc-uso-de-la-iteración-de-punto-fijo-para-resolver-ecuaciones" class="nav-link" data-scroll-target="#uso-de-la-iteración-de-punto-fijo-para-resolver-ecuaciones"><span class="header-section-number">2.3.2</span> Uso de la iteración de punto fijo para resolver ecuaciones</a></li>
  <li><a href="#ejemplo" id="toc-ejemplo" class="nav-link" data-scroll-target="#ejemplo"><span class="header-section-number">2.3.3</span> Ejemplo</a></li>
  <li><a href="#casos-convergentes-y-divergentes" id="toc-casos-convergentes-y-divergentes" class="nav-link" data-scroll-target="#casos-convergentes-y-divergentes"><span class="header-section-number">2.3.4</span> Casos convergentes y divergentes</a></li>
  </ul></li>
  <li><a href="#el-método-de-newton-raphson" id="toc-el-método-de-newton-raphson" class="nav-link" data-scroll-target="#el-método-de-newton-raphson"><span class="header-section-number">2.4</span> El método de Newton-Raphson</a>
  <ul class="collapse">
  <li><a href="#deducción-de-la-fórmula-de-recurrencia" id="toc-deducción-de-la-fórmula-de-recurrencia" class="nav-link" data-scroll-target="#deducción-de-la-fórmula-de-recurrencia"><span class="header-section-number">2.4.1</span> Deducción de la fórmula de recurrencia</a></li>
  <li><a href="#interpretación-geométrica" id="toc-interpretación-geométrica" class="nav-link" data-scroll-target="#interpretación-geométrica"><span class="header-section-number">2.4.2</span> Interpretación geométrica</a></li>
  <li><a href="#convergencia" id="toc-convergencia" class="nav-link" data-scroll-target="#convergencia"><span class="header-section-number">2.4.3</span> Convergencia</a></li>
  <li><a href="#ejemplo-1" id="toc-ejemplo-1" class="nav-link" data-scroll-target="#ejemplo-1"><span class="header-section-number">2.4.4</span> Ejemplo</a></li>
  </ul></li>
  <li><a href="#variantes-del-método-de-newton-raphson" id="toc-variantes-del-método-de-newton-raphson" class="nav-link" data-scroll-target="#variantes-del-método-de-newton-raphson"><span class="header-section-number">2.5</span> Variantes del método de Newton-Raphson</a>
  <ul class="collapse">
  <li><a href="#método-de-la-secante" id="toc-método-de-la-secante" class="nav-link" data-scroll-target="#método-de-la-secante"><span class="header-section-number">2.5.1</span> Método de la secante</a></li>
  <li><a href="#método-de-von-mises" id="toc-método-de-von-mises" class="nav-link" data-scroll-target="#método-de-von-mises"><span class="header-section-number">2.5.2</span> Método de von Mises</a></li>
  <li><a href="#método-de-newton-raphson-de-2º-orden" id="toc-método-de-newton-raphson-de-2º-orden" class="nav-link" data-scroll-target="#método-de-newton-raphson-de-2º-orden"><span class="header-section-number">2.5.3</span> Método de Newton-Raphson de 2º Orden</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/mpru/metodos_numericos/edit/main/02_ecuaciones.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mpru/metodos_numericos/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mpru/metodos_numericos/blob/main/02_ecuaciones.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Resolución de ecuaciones en una variable</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introducción" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="introducción"><span class="header-section-number">2.1</span> Introducción</h2>
<ul>
<li><p>En esta unidad consideraremos uno de los problemas más básicos de la aproximación numérica: <strong>el problema de la búsqueda de la raíz</strong>, es decir, encontrar una <strong>raíz</strong> o <strong>solución</strong> para una ecuación de la forma <span class="math inline">\(f(x) = 0\)</span>, para una función <span class="math inline">\(f\)</span> dada.</p></li>
<li><p>Una raíz de esta ecuación también recibe el nombre de <strong>cero de la función <span class="math inline">\(f\)</span></strong>.</p></li>
<li><p>Generalmente se clasifica a las ecuaciones como <strong>lineales</strong> o <strong>no lineales</strong></p>
<ul>
<li><p>Una <strong>ecuación lineal</strong> es una igualdad que involucra una o más variables elevadas a la primera potencia y no contiene productos entre las variables (involucra solamente sumas y restas de las variables). Por ejemplo: <span class="math inline">\(3x+2 = 8\)</span>.</p>
<p>Para este tipo de ecuaciones es posible hallar analíticamente una expresión para su solución, aunque esto puede resultar en un proceso complejo.</p></li>
<li><p>En una <strong>ecuación no lineal</strong> las incógnitas están elevadas a potencias distintas de <span class="math inline">\(1\)</span>, aparecen en denominadores o exponentes o están afectadas por funciones no lineales (como el logaritmo o las trigonométricas).</p></li>
</ul></li>
<li><p>A las ecuaciones no lineales se las suele clasificar como:</p>
<ul>
<li><p><strong>Ecuaciones algebraicas</strong>: involucran un polinomio igualado a cero:</p>
<p><span class="math display">\[
P_n(x) = a_0 x^n + a_1 x^{n-1} + ... + a_{n-1} x + a_n = 0
\]</span></p>
<p>donde <span class="math inline">\(a_0 \ne 0, n \in \mathbb{N}\)</span> y <span class="math inline">\(a_0, \dots, a_n\)</span> son constantes.</p>
<p>Por ejemplo: <span class="math inline">\(x^3 - x^2 + 5x - 8 = 2x^5\)</span>.</p>
<p>Sabemos que si, por ejemplo, <span class="math inline">\(n = 2\)</span>, la solución de <span class="math inline">\(ax^2 + b x + c = 0\)</span> está dada por la resolvente:</p>
<p><span class="math display">\[
x_{1,2} = \frac{b \pm \sqrt{b^2 - 4ac}}{2a}
\]</span></p>
<p>Sin embargo, la solución análitica para este tipo de ecuaciones existe sólo para <span class="math inline">\(n \le 4\)</span>.</p></li>
<li><p><strong>Ecuaciones trascendentes</strong>: incluyen a los otros tipos de ecuaciones no lineales, como por ejemplo:</p>
<p><span class="math display">\[\begin{gather*}
x^3 - ln (x) + \frac{3}{x} = 2 \\
tg(x + 45) = 1 + sen(2x) \\
xe^{x}=1 \\
{\displaystyle 5^{x}=9^{x+1} 3^{x}}
\end{gather*}\]</span></p>
<p>En general, tampoco es posible hallar de manera analítica una solución exacta para estas ecuaciones.</p></li>
</ul></li>
<li><p>Estudiaremos distintos métodos para encontrar las soluciones aproximadas a ecuaciones de una variable, ya sean estas lineales o no lineales.</p></li>
<li><p>Todos los métodos que desarrollaremos tienen en común el empleo de una técnica fundamental para el análisis numérico: la <strong>iteración</strong>.</p></li>
<li><p>Los <strong>métodos iterativos</strong> repiten un proceso hasta obtener un resultado para el problema.</p></li>
<li><p>Aplicados a la búsqueda de raíces, en general estos métodos requieren de dos pasos generales:</p>
<ol type="1">
<li>Determinar un valor aproximado de la raíz que se busca.</li>
<li>Mejorar la solución hasta lograr un grado de precisión preestablecido.</li>
</ol></li>
</ul>
</section>
<section id="el-método-de-la-bisección-o-búsqueda-binaria" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="el-método-de-la-bisección-o-búsqueda-binaria"><span class="header-section-number">2.2</span> El método de la bisección o búsqueda binaria</h2>
<ul>
<li><p>Se basa en el <strong>teorema de Bolzano</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, que dice que si <span class="math inline">\(f\)</span> es una función continua definida dentro del intervalo <span class="math inline">\([a, b]\)</span> con <span class="math inline">\(f(a)\)</span> y <span class="math inline">\(f(b)\)</span> de signos opuestos, entonces existe un número <span class="math inline">\(p\)</span> en <span class="math inline">\((a, b)\)</span> con <span class="math inline">\(f(p) = 0\)</span> (es decir, <span class="math inline">\(p\)</span> es la solución de la ecuación <span class="math inline">\(f(x) = 0\)</span>).</p></li>
<li><p>El método realiza repetidamente una reducción a la mitad (o <em>bisección</em>) de subintervalos de <span class="math inline">\([a, b]\)</span>, localizando en cada paso la mitad que contiene a <span class="math inline">\(p\)</span>:</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/biseccion1.png" class="img-fluid" width="294"></p>
</div>
</div>
<ul>
<li><p>Para comenzar, sea <span class="math inline">\(a_1 = a\)</span>, <span class="math inline">\(b_1 = b\)</span> y <span class="math inline">\(p_1 = \frac{a_1 + b_1}{2}\)</span> el punto medio de <span class="math inline">\([a, b]\)</span>.</p></li>
<li><p>Si <span class="math inline">\(f(p_1) = 0\)</span>, entonces <span class="math inline">\(p= p_1\)</span> y terminamos (ya encontramos la raíz).</p></li>
<li><p>Si <span class="math inline">\(f(p_1) \neq 0\)</span>:</p>
<ul>
<li>Si <span class="math inline">\(f(a_1)\)</span> y <span class="math inline">\(f(p_1)\)</span> tienen el mismo signo, <span class="math inline">\(p \in (p_1, b_1)\)</span>. Se define el nuevo subintervalo como <span class="math inline">\(a_2 = p_1\)</span> y <span class="math inline">\(b_2 = b_1\)</span>.</li>
<li>Si <span class="math inline">\(f(a_1)\)</span> y <span class="math inline">\(f(p_1)\)</span> tienen signos opuestos, <span class="math inline">\(p \in (a_1, p_1)\)</span>. Se define el nuevo subintervalo como <span class="math inline">\(a_2 = a_1\)</span> y <span class="math inline">\(b_2 = p_1\)</span>.</li>
</ul></li>
<li><p>Se vuelve a aplicar el proceso al intervalo <span class="math inline">\([a_2, b_2]\)</span> y así sucesivamente hasta verificar algún criterio de parada.</p></li>
<li><p>Por ejemplo, podemos seleccionar una tolerancia <span class="math inline">\(\epsilon &gt; 0\)</span> y detener el proceso siguiendo alguna de estas opciones:</p>
<ol type="a">
<li>Cuando la semiamplitud del intervalo sea muy pequeña:</li>
</ol>
<p><span class="math display">\[
  \frac{b-a}{2} &lt; \epsilon
  \]</span></p>
<ol start="2" type="a">
<li>Cuando el valor de la función evaluado en <span class="math inline">\(f(p_n)\)</span> sea muy pequeño (esto implica que <span class="math inline">\(p_n\)</span> está próximo a la raíz):</li>
</ol>
<p><span class="math display">\[
  |f(p_n)| &lt; \epsilon
  \]</span></p>
<ol start="3" type="a">
<li>Cuando la diferencia absoluta o relativa entre dos aproximaciones sucesivas sea muy pequeña:</li>
</ol>
<p><span class="math display">\[
  |p_n - p_{n-1}| &lt; \epsilon
  \]</span></p>
<p><span class="math display">\[
  \frac{|p_n - p_{n-1}|}{|p_n|} &lt; \epsilon, \quad p_N \neq 0
  \]</span></p></li>
<li><p>Estas última serán empleadas en muchos métodos iterativos que estudiaremos, optando generalmente por la que se basa en la diferencia relativa.</p></li>
<li><p>En los métodos iterativos es importante establecer un límite superior sobre el número de iteraciones, para eliminar la posibilidad de entrar en un ciclo infinito (puede ocurrir si la sucesión diverge o si el programa está codificado incorrectamente). El método de la bisección no diverge pero aún así es recomendable establecer esta cota superior para la cantidad de iteraciones.</p></li>
<li><p><strong>Desventajas</strong>:</p>
<ul>
<li>Convergencia lenta (<span class="math inline">\(n\)</span> puede volverse bastante grande antes de que <span class="math inline">\(|p-p_n|\)</span> sea suficientemente pequeño).</li>
<li>Se podría descartar inadvertidamente una buena aproximación intermedia.</li>
</ul></li>
<li><p><strong>Ventajas</strong>:</p>
<ul>
<li>Conceptualmente claro.</li>
<li>Siempre converge a una solución.</li>
</ul></li>
<li><p>Por las características anteriores, con frecuencia se utiliza este método como punto de partida para otros métodos más eficientes.</p></li>
</ul>
</section>
<section id="el-método-del-punto-fijo-o-de-las-aproximaciones-sucesivas" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="el-método-del-punto-fijo-o-de-las-aproximaciones-sucesivas"><span class="header-section-number">2.3</span> El método del punto fijo o de las aproximaciones sucesivas</h2>
<section id="punto-fijo" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="punto-fijo"><span class="header-section-number">2.3.1</span> Punto fijo</h3>
<ul>
<li>Un <em>punto fijo</em> para una función es un número en el que el valor de la función no cambia cuando se aplica la función.</li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: el número <span class="math inline">\(p\)</span> es un <strong>punto fijo</strong> para una función dada <span class="math inline">\(g\)</span> si <span class="math inline">\(g(p) = p\)</span>.</p>
</div>
<ul>
<li><p>Ejemplos:</p>
<ul>
<li><span class="math inline">\(g(x)=x^{2}-3x+4\)</span>: <span class="math inline">\(2\)</span> es un punto fijo de <span class="math inline">\(g\)</span> porque <span class="math inline">\(g(2) = 2\)</span>.</li>
<li><span class="math inline">\(g(x)=x^{2}\)</span>: <span class="math inline">\(0\)</span> y <span class="math inline">\(1\)</span> son puntos fijos de <span class="math inline">\(g\)</span> porque <span class="math inline">\(g(0) = 0\)</span> y <span class="math inline">\(g(1) = 1\)</span>.</li>
</ul></li>
<li><p>El problema de encontrar la raíz <span class="math inline">\(p\)</span> de una ecuación <span class="math inline">\(f(x) = 0\)</span> puede ser planteado de forma equivalente como la búsqueda del punto fijo de alguna función <span class="math inline">\(g(x)\)</span>.</p></li>
<li><p>Antes de ver cómo es eso, tenemos que saber cuándo una función tiene un punto fijo y cómo aproximarlo.</p></li>
</ul>
<section id="interpretación-gráfica" class="level4" data-number="2.3.1.1">
<h4 data-number="2.3.1.1" class="anchored" data-anchor-id="interpretación-gráfica"><span class="header-section-number">2.3.1.1</span> Interpretación gráfica</h4>
<ul>
<li><p>Dado que un punto fijo es el valor de <span class="math inline">\(x\)</span> que satisface <span class="math inline">\(x = g(x)\)</span>, un punto fijo para <span class="math inline">\(g\)</span> ocurre precisamente cuando la gráfica de <span class="math inline">\(y = g(x)\)</span> interseca la gráfica de <span class="math inline">\(y=x\)</span> (recta identidad).</p></li>
<li><p>Por ejemplo, vamos a encontrar los puntos fijos de la función <span class="math inline">\(g(x) = x^2 - 2\)</span>. Si graficamos esta curva junto con la recta identidad, encontraremos los puntos fijos de <span class="math inline">\(g\)</span> allí donde ambas se cruzan:</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo1.png" class="img-fluid" style="width:40.0%"></p>
</div>
</div>
<ul>
<li>En la figura podemos observar que los puntos fijos son <span class="math inline">\(-1\)</span> y <span class="math inline">\(2\)</span>. De hecho: <span class="math inline">\(g(-1) = 1 - 2 = -1\)</span> y <span class="math inline">\(g(2) = 4 - 2 = 2\)</span>.</li>
</ul>
</section>
<section id="cómo-encontrar-un-punto-fijo" class="level4" data-number="2.3.1.2">
<h4 data-number="2.3.1.2" class="anchored" data-anchor-id="cómo-encontrar-un-punto-fijo"><span class="header-section-number">2.3.1.2</span> Cómo encontrar un punto fijo</h4>
<ul>
<li><p>Para aproximar el punto fijo de una función <span class="math inline">\(g\)</span>, elegimos una aproximación inicial <span class="math inline">\(p_0\)</span> y generamos la sucesión <span class="math inline">\(\{p_n\}_{n=0}^\infty\)</span> al permitir <span class="math inline">\(p_n = g(p_{n-1})\)</span> para cada <span class="math inline">\(n \geq 1\)</span>:</p>
<p><span class="math display">\[\begin{gather*}
p_0 \\
p_1 = g(p_0) \\
p_2 = g(p_1) \\
\vdots \\
p_n = g(p_{n-1}) \\
\vdots \\
\end{gather*}\]</span></p></li>
<li><p>Si <span class="math inline">\(g\)</span> es continua y la sucesión converge a un número <span class="math inline">\(p\)</span>, entonces éste es el punto fijo de <span class="math inline">\(g\)</span>. Demostración:</p>
<ul>
<li>La sucesión converge a <span class="math inline">\(p \implies p = \lim_{n \rightarrow \infty} p_n\)</span>.</li>
<li>Por otro lado, <span class="math inline">\(\lim_{n \rightarrow \infty} p_n= \lim_{n \rightarrow \infty} g(p_{n-1}) = g\big( \lim_{n \rightarrow \infty} p_{n-1} \big) = g(p)\)</span>.</li>
<li>De los dos ítems anteriores, resulta que <span class="math inline">\(p = g(p)\)</span>, con lo cual <span class="math inline">\(p\)</span> es un punto fijo de <span class="math inline">\(g\)</span>.</li>
</ul></li>
<li><p>Esta técnica se conoce como <strong>iteración de punto fijo</strong> o <strong>iteración funcional</strong>.</p></li>
<li><p>Ejemplos:</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo3.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
</section>
<section id="teorema-de-punto-fijo" class="level4" data-number="2.3.1.3">
<h4 data-number="2.3.1.3" class="anchored" data-anchor-id="teorema-de-punto-fijo"><span class="header-section-number">2.3.1.3</span> Teorema de punto fijo</h4>
<ul>
<li><p>No todas las funciones tienen un punto fijo y aunque lo tengan no siempre la sucesión anterior nos conduce al mismo.</p></li>
<li><p>El siguiente teorema proporciona condiciones suficientes para garantizar la existencia y unicidad de un punto fijo y para que la sucesión converja al mismo.</p></li>
</ul>
<div class="alert alert-info">
<p><strong>Teorema de punto fijo</strong>:</p>
<ol type="i">
<li><p>Si <span class="math inline">\(g\)</span> es continua en <span class="math inline">\([a, b]\)</span> y <span class="math inline">\(g(x) \in [a, b]\)</span> para todo <span class="math inline">\(x \in [a, b]\)</span>, entonces <span class="math inline">\(g\)</span> tiene por lo menos un punto fjo en <span class="math inline">\([a, b]\)</span>.</p></li>
<li><p>Si, además, <span class="math inline">\(g'(x)\)</span> existe en <span class="math inline">\((a, b)\)</span> y existe una constante <span class="math inline">\(0&lt;k&lt;1\)</span> con</p>
<p><span class="math display">\[
|g'(x)| \leq k \quad \forall x \in (a,b),
\]</span></p>
<p>entonces existe exactamente un punto fijo <span class="math inline">\(p\)</span> en <span class="math inline">\([a, b]\)</span> y para cualquier número <span class="math inline">\(p_0\)</span> en <span class="math inline">\([a, b]\)</span>, la sucesión definida por:</p>
<p><span class="math display">\[
p_n = g(p_{n-1}), \qquad n \geq 1
\]</span></p>
<p>converge al único punto <span class="math inline">\(p\)</span> en <span class="math inline">\([a, b]\)</span>.</p></li>
</ol>
</div>
<ul>
<li>La siguiente imagen ejemplifica la primera condición establecida por el teorema:</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo2.png" class="img-fluid" style="width:60.0%"></p>
</div>
</div>
<ul>
<li>Estas condiciones son suficientes pero no necesarias (la función puede tener un único punto fijo aunque no se cumplan).</li>
</ul>
</section>
</section>
<section id="uso-de-la-iteración-de-punto-fijo-para-resolver-ecuaciones" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="uso-de-la-iteración-de-punto-fijo-para-resolver-ecuaciones"><span class="header-section-number">2.3.2</span> Uso de la iteración de punto fijo para resolver ecuaciones</h3>
<ul>
<li><p>Sea la ecuación a resolver:</p>
<p><span class="math display">\[f(x) = 0\]</span></p></li>
<li><p>Siempre es posible reexpresarla en la forma:</p>
<p><span class="math display">\[
x = g(x)
\]</span></p>
<p>con alguna función <span class="math inline">\(g\)</span>.</p></li>
<li><p>Esto se logra despejando alguna <span class="math inline">\(x\)</span> o, por ejemplo, sumando <span class="math inline">\(x\)</span> a cada miembro de la ecuación:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp;= f(x) \\
x + 0 &amp;= x + f(x) \\
x &amp;= \underbrace{x + f(x)}_{g(x)}
\end{aligned}
\]</span></p></li>
<li><p>Llamemos con <span class="math inline">\(p\)</span> a la solución de la ecuación, es decir, al valor que satisface <span class="math inline">\(f(x) = 0\)</span>.</p></li>
<li><p>Si <span class="math inline">\(p\)</span> satisface <span class="math inline">\(f(x) = 0\)</span>, entonces también satisface <span class="math inline">\(x = g(x)\)</span> (puesto que es la misma ecuación escrita de otra forma).</p></li>
<li><p>Entonces, la raíz buscada es el punto fijo de <span class="math inline">\(g\)</span>.</p></li>
<li><p>Así, el <strong>método de iteración de punto fijo o de aproximaciones sucesivas</strong> para resolver <span class="math inline">\(f(x) = 0\)</span> consiste en:</p>
<ol type="1">
<li>Expresar la ecuación en la forma <span class="math inline">\(x = g(x)\)</span>.</li>
<li>Elegir un valor inicial adecuado <span class="math inline">\(p_0\)</span>.</li>
<li>Realizar el siguiente cálculo iterativo:</li>
</ol>
<p><span class="math display">\[\begin{gather*}
  p_0 \\
  p_1 = g(p_0) \\
  p_2 = g(p_1) \\
  \vdots \\
  p_n = g(p_{n-1}) \\
  \vdots \\
  \end{gather*}\]</span></p></li>
<li><p>Si a medida que <span class="math inline">\(n\)</span> crece los <span class="math inline">\(p_n\)</span> se aproximan a un valor fijo, se dice que el método converge y la iteración se detiene cuando la diferencia entre dos valores consecutivos <span class="math inline">\(p_{n-1}\)</span> y <span class="math inline">\(p_n\)</span> sea tan pequeña como se desee, a juzgar por los criterios de parada mencionados anteriormente.</p></li>
<li><p>El valor <span class="math inline">\(p_n\)</span> será una raíz aproximada de <span class="math inline">\(f(x)\)</span>.</p></li>
</ul>
</section>
<section id="ejemplo" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="ejemplo"><span class="header-section-number">2.3.3</span> Ejemplo</h3>
<ul>
<li><p>Hallar las raíces de la ecuación no lineal: <span class="math inline">\(f(x) = x^2-3x+e^x-2=0\)</span></p></li>
<li><p>Graficamos y vemos que las raíces están cercanas a -0.4 y 1.4 (podés hacer estos gráficos rápidamente con <a href="https://www.geogebra.org/calculator">Geogebra</a>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo4.png" class="img-fluid" width="1500"></p>
</div>
</div></li>
</ul>
<p><strong>Paso 1: postular <span class="math inline">\(g(x)\)</span></strong></p>
<ul>
<li><p>Reescribimos <span class="math inline">\(f(x) = 0\)</span> como <span class="math inline">\(x = g(x)\)</span></p></li>
<li><p>Por ejemplo, despejando la <span class="math inline">\(x\)</span> del segundo término:</p>
<p><span class="math display">\[f(x) = x^2-3x+e^x-2 = 0\]</span> <span class="math display">\[\implies x =  \underbrace{\frac{x^2+e^x-2}{3}}_{g(x)}\]</span> <span class="math display">\[\implies g(x)= \frac{x^2+e^x-2}{3}\]</span></p></li>
</ul>
<p><strong>Paso 2: verificar si <span class="math inline">\(g(x)\)</span> cumple las condiciones del teorema</strong></p>
<ul>
<li><p>Vamos a concentrarnos en la raíz negativa, para ver si las condiciones del teorema se verifican en una vecindad de la misma.</p></li>
<li><p>Necesitamos calcular la derivada de <span class="math inline">\(g\)</span>:</p>
<p><span class="math display">\[g'(x) = \frac{1}{3}(2x+e^x)\]</span></p></li>
<li><p>La forma más fácil de hacer la verificación es usando una gráfica. Hay que tomar un intervalo <span class="math inline">\([a, b]\)</span> que contenga a la raíz y graficar <span class="math inline">\(g\)</span> y <span class="math inline">\(g'\)</span> para poder observar el cumplimiento o no de las condiciones.</p></li>
<li><p>Tomemos arbitrariamente el intervalo <span class="math inline">\([-1.5, 0.5]\)</span>. En la siguiente figura podemos ver que <span class="math inline">\(g\)</span> es continua allí y que <span class="math inline">\(g(x) \in [a, b]\)</span> para todo <span class="math inline">\(x \in [a, b]\)</span> (la curva “sale por los costados” del cuadrado delimitado por el intervalo de interés).</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo10.png" class="img-fluid" width="406"></p>
</div>
</div></li>
<li><p>La siguiente figura muestra la derivada, confirmando que está acotada por 1 en valor absoluto:</p>
<p><span class="math display">\[
g'(x) = \frac{1}{3} (2x+e^x)
\]</span></p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo11.png" class="img-fluid" width="337"></p>
</div>
</div></li>
<li><p>Lo anterior implica que hay una raíz dentro del intervalo <span class="math inline">\([-1.5, 0.5]\)</span> y que empezando la sucesión con cualquier valor dentro del mismo vamos a llegar a la misma.</p></li>
<li><p>Otra forma es demostrar analíticamente, por ejemplo, que la derivada está acotada por el valor <span class="math inline">\(1\)</span> en valor absoluto en intervalo analizado. Como esto puede ser “complejo”, en la práctica a veces miramos sencillamente que tanto <span class="math inline">\(|g'(a)|\)</span> como <span class="math inline">\(|g'(b)|\)</span> sean menores que <span class="math inline">\(1\)</span> (pero hay que tener cuidado, que se cumpla en los extremos de los intervalos no quiere decir que se cumpla en todo el intervalo).</p></li>
<li><p>Si no se cumplen las condiciones, podemos probar igualmente si el método converge (aunque no hay garantías de eso) o probar con otra expresión para <span class="math inline">\(g(x)\)</span> que sí cumpla con las condiciones.</p></li>
</ul>
<p><strong>Paso 3: elegir un punto inicial y realizar las iteraciones</strong></p>
<ul>
<li><p>Imaginemos que en búsqueda de la raíz negativa estamos considerando el intervalo <span class="math inline">\([-1.5, 0.5]\)</span> que como sabemos verifica las condiciones del teorema.</p></li>
<li><p>Debemos tomar cualquier punto <span class="math inline">\(p_0\)</span> dentro de este intervalo para iniciar el proceso iterativo.</p></li>
<li><p>La fórmula de recurrencia es:</p>
<p><span class="math display">\[
p_n= g(p_{n-1})=\frac{p_{n-1}^2+e^{p_{n-1}}-2}{3}, \qquad n = 1, 2, ...
\]</span></p>
<p>que en este caso imlica:</p>
<p><span class="math display">\[
p_n= \frac{p_{n-1}^2+e^{p_{n-1}}-2}{3}, \qquad n = 1, 2, ...
\]</span></p></li>
<li><p>Tomando <span class="math inline">\(p_0 = -1.5\)</span>, el proceso converge al valor <span class="math inline">\(-0.390271\)</span> que consideraremos como la aproximación para la raíz buscada.</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo5.jpg" class="img-fluid" style="width:20.0%"></p>
</div>
</div>
<ul>
<li><p>Verificar estos resultados (pueden hacerlo rápidamente en una planilla de Excel).</p></li>
<li><p>Para saber cuándo detenernos, podemos fijar una toleracia <span class="math inline">\(\epsilon = 1E-6\)</span> (por ejemplo) y parar el proceso cuando la diferencia relativa entre dos aproximaciones sucesivas sea menor:</p></li>
</ul>
<p><span class="math display">\[
\frac{|p_N - p_{N-1}|}{|p_N|} &lt; \epsilon = 1E-6
\]</span></p>
<p>::: {.cell} ::: {.cell-output-display} <img src="Plots/Un2/puntofijo6.jpg" class="img-fluid" style="width:30.0%"> ::: :::</p>
<p><strong>Paso 4: representar gráficamente</strong></p>
<ul>
<li>Como hemos mencionado, el punto fijo de <span class="math inline">\(g\)</span> se encuentra en el lugar donde la recta identidad interseca a <span class="math inline">\(g\)</span>.</li>
<li>Una gráfica de ambas nos permite visualizar el proceso iterativo de forma gráfica (la curva azul es <span class="math inline">\(g(x)\)</span> y la roja es la recta identidad):</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">"Plots/Un2/puntofijo7.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo7.png" class="img-fluid" style="width:60.0%"></p>
</div>
</div>
</section>
<section id="casos-convergentes-y-divergentes" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="casos-convergentes-y-divergentes"><span class="header-section-number">2.3.4</span> Casos convergentes y divergentes</h3>
<ul>
<li>Las siguientes figuras presentan algunos ejemplos de convergencia y divergencia del proceso:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">"Plots/Un2/puntofijo8.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo8.png" class="img-fluid" style="width:60.0%"></p>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">"Plots/Un2/puntofijo9.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Plots/Un2/puntofijo9.png" class="img-fluid" style="width:60.0%"></p>
</div>
</div>
</section>
</section>
<section id="el-método-de-newton-raphson" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="el-método-de-newton-raphson"><span class="header-section-number">2.4</span> El método de Newton-Raphson</h2>
<ul>
<li><p>El método de Newton (o de Newton-Raphson) es uno de los métodos numéricos más poderosos y reconocidos para resolver un problema de encontrar la raíz.</p></li>
<li><p>Este método propone tomar una aproximación inicial <span class="math inline">\(p_0\)</span> para la raíz de la ecuación <span class="math inline">\(f(x) = 0\)</span> y generar la sucesión <span class="math inline">\(\{p_n\}_{n=0}^\infty\)</span> mediante:</p>
<p><span class="math display">\[
p_n = p_{n-1} - \frac{f(p_{n-1})}{f'(p_{n-1})} \qquad n \geq 1
\]</span></p></li>
<li><p>Si se cumplen ciertas condiciones generales que estudiaremos más adelante, esta sucesión converge al verdadero valor buscado, la raíz <span class="math inline">\(p\)</span>.</p></li>
<li><p>Para detener las iteraciones se emplea alguno de los criterios de parada mencionados cuando vimos el método de la bisección.</p></li>
<li><p>Antes de ver cuáles son esas condiciones, vamos a ver de dónde surge esta fórmula de recurrencia y cómo la podemos interpretar geométricamente.</p></li>
</ul>
<section id="deducción-de-la-fórmula-de-recurrencia" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="deducción-de-la-fórmula-de-recurrencia"><span class="header-section-number">2.4.1</span> Deducción de la fórmula de recurrencia</h3>
<ul>
<li><p>Supongamos que <span class="math inline">\(f\)</span> es continua en un intervalo <span class="math inline">\([a, b]\)</span> y tiene derivadas primera y segunda continuas en el mismo intervalo.</p></li>
<li><p>Tomemos <span class="math inline">\(p_0 \in [a,b]\)</span> como un valor que se aproxima para <span class="math inline">\(p\)</span> y consideremos el polinomio de Taylor de grado 1 para aproximar <span class="math inline">\(f(x)\)</span> alrededor de <span class="math inline">\(p_0\)</span>:</p>
<p><span class="math display">\[f(x) = f(p_0) + (x-p_0) f'(p_0)+ \underbrace{\frac{(x-p_0)^2}{2!}f''(\xi)}_{\text{resto, } \xi \text{ real entre } x \text{ y }p_0}\]</span></p></li>
<li><p>Ahora, evaluemos el polinomio de Taylor en el valor verdadero <span class="math inline">\(p\)</span>:</p>
<p><span class="math display">\[\text{Por ser $p$ la raíz de $f$:} \quad f(p) = 0\]</span></p>
<p><span class="math display">\[\text{Por el desarrollo de Taylor:} \quad f(p) = f(p_0) + (p-p_0) f'(p_0)+ \underbrace{\frac{(p-p_0)^2}{2!}f''(\xi)}_{\text{resto, } \xi \text{ real entre } p \text{ y }p_0}\]</span></p>
<p><span class="math display">\[\text{Entonces:}\quad 0 = f(p_0) + (p-p_0) f'(p_0)+\frac{(p-p_0)^2}{2!}f''(\xi)\]</span></p></li>
<li><p>Si <span class="math inline">\(p_0\)</span> es una aproximación adecuada, <span class="math inline">\(|p-p_0|\)</span> debe ser pequeño y entonces el término relacionado a <span class="math inline">\((p-p_0)^2\)</span>, mucho más pequeño y puede ser descartado, de modo que:</p>
<p><span class="math display">\[0 \approx f(p_0) + (p-p_0) f'(p_0)\]</span></p></li>
<li><p>Al despejar <span class="math inline">\(p\)</span> tenemos:</p>
<p><span class="math display">\[
p \approx p_{0} - \frac{f(p_{0})}{f'(p_{0})} \equiv p_1
\]</span></p></li>
<li><p>Llamamos al valor anterior <span class="math inline">\(p_1\)</span> y repetimos el procedimiento planteando el desarrollo en serie de Taylor de <span class="math inline">\(f\)</span> alrededor de <span class="math inline">\(p_1\)</span>, encontrando que:</p>
<p><span class="math display">\[
p \approx p_{1} - \frac{f(p_{1})}{f'(p_{1})} \equiv p_2
\]</span></p></li>
<li><p>Si seguimos repitiendo esto, damos lugar a una sucesión que debe acercarnos cada vez más al verdadero valor de <span class="math inline">\(p\)</span>:</p>
<p><span class="math display">\[
p_n = p_{n-1} - \frac{f(p_{n-1})}{f'(p_{n-1})} \qquad n \geq 1
\]</span></p></li>
</ul>
</section>
<section id="interpretación-geométrica" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="interpretación-geométrica"><span class="header-section-number">2.4.2</span> Interpretación geométrica</h3>
<ul>
<li>Recordemos la definición de recta tangente:</li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: una recta se dice que es <strong>tangente</strong> a una función <span class="math inline">\(f\)</span> en un punto <span class="math inline">\(a\)</span> cuando pasa por ese punto y su pendiente es <span class="math inline">\(f'(a)\)</span>. La ecuación de la recta tangente a la gráfica de la función en el punto <span class="math inline">\((a, f(a))\)</span> es:</p>
<p><span class="math display">\[
y = f(a) + f'(a) (x - a)
\]</span></p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/nr1.png" class="img-fluid" style="width:60.0%"></p>
</div>
</div>
</div>
<ul>
<li><p>La fórmula de recurrencia presentada anteriormente equivale a encontrar el próximo valor <span class="math inline">\(p_n\)</span> como el punto en el que el eje de las abscisas interseca a la recta tangente a la gráfica de <span class="math inline">\(f\)</span> en <span class="math inline">\((p_{n-1}, f(p_{n-1}))\)</span>.</p></li>
<li><p>Es decir, al empezar con la aproximación inicial <span class="math inline">\(p_0\)</span>, la aproximación <span class="math inline">\(p_1\)</span> es la intersección con el eje <span class="math inline">\(x\)</span> de la recta tangente a la gráfica de <span class="math inline">\(f\)</span> en <span class="math inline">\((p_0, f(p_0)\)</span>.</p></li>
<li><p>La aproximación <span class="math inline">\(p_2\)</span> es la intersección con el eje <span class="math inline">\(x\)</span> de la recta tangente a la gráfica de <span class="math inline">\(f\)</span> en <span class="math inline">\((p_1, f(p_1)\)</span> y así sucesivamente:</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/nr2.png" class="img-fluid" width="256"></p>
</div>
</div>
<ul>
<li><p>¿De dónde sale que la fórmula de recurrencia equivale a esto de avanzar en la sucesión de acuerdo a las rectas tangentes? Hay que prestarle atención a las pendientes.</p></li>
<li><p>Por ejemplo, por definición de recta tangente, sabemos que la pendiente de la tangente a <span class="math inline">\(f\)</span> en <span class="math inline">\(p_0\)</span> es igual a:</p>
<p><span class="math display">\[
m = f'(p_0)
\]</span></p></li>
<li><p>Pero también sabemos que la pendiente se puede definir como el siguiente cociente, donde <span class="math inline">\((x_0, y_0)\)</span> y <span class="math inline">\((x_1, y_1)\)</span> son dos puntos cualesquiera pertenecientes a la recta:</p>
<p><span class="math display">\[
m = \frac{y_1 - y_0}{x_1 - x_0}
\]</span></p></li>
<li><p>Podemos tomar los puntos <span class="math inline">\((p_0, f(p_0))\)</span> y <span class="math inline">\((p_1, 0)\)</span> (el punto donde la tangente interseca al eje <span class="math inline">\(x\)</span>) y encontrar una expresión para la pendiente de la tangente:</p>
<p><span class="math display">\[
m = \frac{y_1 - y_0}{x_1 - x_0} =  \frac{0 - f(p_0)}{p_1 - p_0}=  -\frac{f(p_0)}{p_1 - p_0}
\]</span></p></li>
<li><p>Igualando las dos expresiones equivalentes vistas para la pendiente <span class="math inline">\(m\)</span>:</p>
<p><span class="math display">\[
f'(p_0) =  -\frac{f(p_0)}{p_1 - p_0} \implies
p_1 = p_{0} - \frac{f(p_{0})}{f'(p_{0})}
\]</span></p></li>
<li><p>Si repetimos este pensamiento con la recta tangente a <span class="math inline">\(f\)</span> en el punto <span class="math inline">\(p_1\)</span>, vamos a encontrar que:</p>
<p><span class="math display">\[
  p_2 = p_1 - \frac{f(p_1)}{f'(p_1)}
  \]</span></p></li>
<li><p>Esto constituye una derivación geométrica del método de Newton-Raphson desde el punto de vista de las rectas tangentes a <span class="math inline">\(f\)</span> en los puntos <span class="math inline">\(p_{n}\)</span>.</p></li>
</ul>
</section>
<section id="convergencia" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="convergencia"><span class="header-section-number">2.4.3</span> Convergencia</h3>
<ul>
<li>La derivación del método de Newton por medio de la serie de Taylor señala la importancia de una aproximación inicial precisa.</li>
<li>La suposición crucial es que el término relacionado con <span class="math inline">\((p - p_0)^2\)</span> es, en comparación con <span class="math inline">\(|p - p_0|\)</span>, tan pequeño que se puede eliminar.</li>
<li>Claramente esto será falso a menos que <span class="math inline">\(p_0\)</span> sea una buena aproximación para <span class="math inline">\(p\)</span>. Si no lo es, no existen razones para sospechar que el método convergerá en la raíz (aunque en algunos casos incluso malas aproximaciones iniciales producen convergencia).</li>
<li>El siguiente teorema establece cuáles son las condiciones para el método converja, que básicamente se resumen en el hecho de que <span class="math inline">\(p_0\)</span> tiene que estar suficientemente cerca de <span class="math inline">\(p\)</span>.</li>
</ul>
<div class="alert alert-info">
<p><strong>Teorema: convergencia del método de Newton-Raphson</strong>:</p>
<p>Sea <span class="math inline">\(f\)</span> continua en un intervalo <span class="math inline">\([a, b]\)</span> con derivadas primera y segunda continuas en el mismo intervalo. Si <span class="math inline">\(p \in (a,b)\)</span> es tal que <span class="math inline">\(f(p)=0\)</span> y <span class="math inline">\(f'(p) \neq 0\)</span>, entonces existe <span class="math inline">\(\delta &gt;0\)</span> tal que el método de Newton-Raphson genera una sucesión <span class="math inline">\(\{p_n\}_{n=0}^\infty\)</span> que converge a <span class="math inline">\(p\)</span> para cualquier aproximación inicial <span class="math inline">\(p_0 \in [p-\delta,p+\delta]\)</span>.</p>
</div>
<ul>
<li><p>El teorema se demuestra considerando que la sucesión propuesta por el método es una iteración de punto fijo. Repetimos la fórmula de recurrencia:</p>
<p><span class="math display">\[
p_n = \underbrace{p_{n-1} - \frac{f(p_{n-1})}{f'(p_{n-1})}}_{g(p_{n-1})}  \qquad n \geq 1
\]</span></p></li>
<li><p>Vemos que se trata de una iteración de punto fijo <span class="math inline">\(p_n = g(p_{n-1})\)</span>, en la que la función <span class="math inline">\(g\)</span> es:</p>
<p><span class="math display">\[
g(x) = x - \frac{f(x)}{f'(x)}
\]</span></p></li>
<li><p>Por lo tanto, el método converge cuando se cumplen las condiciones del Teorema del punto fijo:</p>
<ol type="i">
<li><span class="math inline">\(g\)</span> es continua en <span class="math inline">\([a, b]\)</span> y <span class="math inline">\(g(x) \in [a, b]\)</span> para todo <span class="math inline">\(x \in [a, b]\)</span>.</li>
<li><span class="math inline">\(g'(x)\)</span> existe en <span class="math inline">\((a, b)\)</span> y existe una constante <span class="math inline">\(0&lt;k&lt;1\)</span> con tal que <span class="math inline">\(|g'(x)| \leq k &lt; 1\)</span>.</li>
</ol></li>
<li><p>Analicemos solamente la condición acerca de que la derivada de <span class="math inline">\(g\)</span> tiene que estar acotada:</p>
<p><span class="math display">\[|g'(x)| \leq k &lt; 1\]</span></p></li>
<li><p>Tomamos la derivada:</p></li>
</ul>
<p><span class="math display">\[g'(x) = 1 - \frac{[f'(x)]^2 - f(x)f''(x)}{[f'(x)]^2} = 1 - 1 + \frac{f(x)f''(x)}{[f'(x)]^2} = \frac{f(x)f''(x)}{[f'(x)]^2}\]</span></p>
<ul>
<li><p>Es decir, el método convergerá si:</p>
<p><span class="math display">\[|g'(x)| = \frac{|f(x)f''(x)|}{[f'(x)]^2} \leq k &lt; 1\]</span></p></li>
<li><p>Por hipótesis, sabemos que <span class="math inline">\(f(p) = 0\)</span>; luego <span class="math inline">\(g'(p) = 0\)</span>. Como <span class="math inline">\(g'(x)\)</span> es continua y <span class="math inline">\(g'(p) = 0\)</span>, siempre podemos encontrar un <span class="math inline">\(\delta &gt; 0\)</span> tal que <span class="math inline">\(|g'(x)| &lt; 1\)</span> se cumpla en el intervalo <span class="math inline">\([p - \delta, p + \delta]\)</span>.</p></li>
<li><p>Por consiguiente, que <span class="math inline">\(p_0\)</span> se encuentre dentro de <span class="math inline">\([p - \delta, p + \delta]\)</span> es una condición suficiente para que la sucesión <span class="math inline">\(\{x_n\}_{n=0}^{\infty}\)</span> converja a la única raíz de <span class="math inline">\(f(x) = 0\)</span> en dicho intervalo.</p></li>
<li><p>La condición anterior tiene las siguientes implicancias. Para facilitar la convergencia:</p>
<ul>
<li><span class="math inline">\(p_0\)</span> tiene que estar suficientemente cerca de <span class="math inline">\(p\)</span>.</li>
<li><span class="math inline">\(f''(x)\)</span> no debe ser muy grande y <span class="math inline">\(f'(x)\)</span> no debe ser muy chica en ese intervalo.</li>
</ul></li>
<li><p>Si bien el teorema sirve para asegurar la convergencia, no dice cómo determinar <span class="math inline">\(\delta\)</span>, así que en la práctica se selecciona una aproximación inicial y se generan aproximaciones sucesivas con el método de Newton. Puede que éstos converjan rápidamente a la raíz o será claro que la convergencia es poco probable.</p></li>
<li><p><em>Observación</em>: el método no puede continuar si <span class="math inline">\(f'(p_{n-1}) = 0\)</span> para alguna <span class="math inline">\(n\)</span>.</p></li>
</ul>
</section>
<section id="ejemplo-1" class="level3" data-number="2.4.4">
<h3 data-number="2.4.4" class="anchored" data-anchor-id="ejemplo-1"><span class="header-section-number">2.4.4</span> Ejemplo</h3>
<ul>
<li><p>Retomemos el ejemplo anterior en cual buscábamos las raíces de la ecuación no lineal: <span class="math inline">\(f(x) = x^2-3x+e^x-2=0\)</span></p></li>
<li><p>Mediante el método del punto fijo reformulamos la ecuación anterior como <span class="math inline">\(x = g(x)\)</span> con:</p>
<p><span class="math display">\[g(x)= \frac{x^2+e^x-2}{3}\]</span></p></li>
<li><p>De esa forma pudimos hallar la raíz negativa.</p></li>
<li><p>Sin embargo, el método no sirve para hallar la raíz positiva (verificar que no se cumplen las condiciones del teorema en vecindades de la raíz).</p></li>
<li><p>Si bien podríamos probar con otra expresión para <span class="math inline">\(g(x)\)</span>, ¿podrá el método de Newton-Raphson sernos útil en este caso?</p></li>
<li><p>Verificar.</p></li>
</ul>
</section>
</section>
<section id="variantes-del-método-de-newton-raphson" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="variantes-del-método-de-newton-raphson"><span class="header-section-number">2.5</span> Variantes del método de Newton-Raphson</h2>
<section id="método-de-la-secante" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="método-de-la-secante"><span class="header-section-number">2.5.1</span> Método de la secante</h3>
<ul>
<li><p>El método de Newton es una técnica en extremo poderosa, pero tiene una debilidad importante: la necesidad de conocer el valor de la derivada de <span class="math inline">\(f\)</span> en cada aproximación.</p></li>
<li><p><span class="math inline">\(f'(x)\)</span> puede ser más difícil y necesitar más operaciones aritméticas para ser calculada que <span class="math inline">\(f(x)\)</span>.</p></li>
<li><p>Para evitar el problema de la evaluación de la derivada, el método de la secante presenta una ligera variación.</p></li>
<li><p>Por definición de derivada:</p>
<p><span class="math display">\[
  f'(p_{n-1}) = \lim_{x \rightarrow p_{n-1}} \frac{f(x) - f(p_{n-1})}{x- p_{n-1}}
  \]</span></p></li>
<li><p>Si <span class="math inline">\(p_{n-2}\)</span> está cerca de <span class="math inline">\(p_{n-1}\)</span>:</p>
<p><span class="math display">\[
  f'(p_{n-1}) \approx  \frac{f(p_{n-2}) - f(p_{n-1})}{p_{n-2}- p_{n-1}} = \frac{f(p_{n-1}) - f(p_{n-2})}{p_{n-1}- p_{n-2}}
  \]</span></p></li>
<li><p>Usando esta aproximación en la fórmula de Newton obtenemos:</p>
<p><span class="math display">\[
p_n = p_{n-1} - \frac{f(p_{n-1})(p_{n-1}- p_{n-2})}{f(p_{n-1}) - f(p_{n-2})} \qquad n \geq 2
\]</span></p></li>
<li><p>Notar que se necesitan dos aproximaciones iniciales.</p></li>
<li><p>Este método también goza de una interpretación geométrica que es la que le da su nombre.</p></li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: una recta <strong>secante</strong> es una recta que corta a una curva <span class="math inline">\(f\)</span> en dos o más puntos. Conforme estos puntos se acercan y su distancia se reduce a cero, la recta secante pasa a ser la <em>recta tangente</em>.</p>
<p>La ecuación de la recta secante a <span class="math inline">\(f\)</span> que pasa por los puntos <span class="math inline">\((x_1, f(x_1))\)</span> y <span class="math inline">\((x_2, f(x_2))\)</span> es (fórmula de la recta que pasa por dos puntos):</p>
<p><span class="math display">\[
y = f(x_1) + \frac{f(x_2) - f(x_1)}{x_2 - x_1} (x - x_1)
\]</span></p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/secante1.png" class="img-fluid" width="154"></p>
</div>
</div>
</div>
<ul>
<li><p>Empezando con dos aproximaciones iniciales <span class="math inline">\(p_0\)</span> y <span class="math inline">\(p_1\)</span>, la aproximación <span class="math inline">\(p_2\)</span> es la intersección en <span class="math inline">\(x\)</span> de la recta que une los puntos <span class="math inline">\((p_0, f(p_0))\)</span> y <span class="math inline">\((p_1, f(p_1))\)</span>.</p></li>
<li><p>La aproximación <span class="math inline">\(p_3\)</span> es la intersección en <span class="math inline">\(x\)</span> de la recta que une los puntos <span class="math inline">\((p_1, f(p_1))\)</span> y <span class="math inline">\((p_2, f(p_2))\)</span> y así sucesivamente.</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/secante2.png" class="img-fluid" width="226"></p>
</div>
</div>
<ul>
<li><em>Observación</em>: sólo se necesita una evaluación de la función por cada paso para el método de la secante después de haber determinado <span class="math inline">\(p_2\)</span>. En contraste, cada paso del método de Newton requiere una evaluación tanto de la función como de su derivada.</li>
</ul>
</section>
<section id="método-de-von-mises" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="método-de-von-mises"><span class="header-section-number">2.5.2</span> Método de von Mises</h3>
<ul>
<li><p>En el método de Newton-Raphson, el denominador <span class="math inline">\(f'(p_{n-1})\)</span> hace que geométricamente se pase de una aproximación a la siguiente por la tangente de la curva <span class="math inline">\(y = f(x)\)</span> en el punto correspondiente a la aproximación presente <span class="math inline">\(p_{n-1}\)</span>.</p></li>
<li><p>Esto puede producir problemas cuando se esté en puntos alejados de raíces y cerca de puntos donde el valor de <span class="math inline">\(f'(x)\)</span> sea cercano a 0 (tangentes cercanas a la horizontal).</p></li>
<li><p>Para resolver este problema, von Mises sugirió sustituir <span class="math inline">\(f'(p_{n-1})\)</span> en el denominador por <span class="math inline">\(f'(p_{0})\)</span>.</p></li>
<li><p>Es decir, obtener las aproximaciones de la sucesión por medio de rectas que son todas paralelas a la primera tangente.</p></li>
<li><p>La fórmula de recurrencia resultante es:</p>
<p><span class="math display">\[
p_n = p_{n-1} - \frac{f(p_{n-1})}{f'(p_{0})} \qquad n \geq 1
\]</span></p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/Un2/vonmises1.png" class="img-fluid" style="width:75.0%"></p>
</div>
</div>
<ul>
<li>Si la derivada requiere muchos cálculos, este método posee la ventaja de que la misma sólo debe ser evaluada una vez.</li>
</ul>
</section>
<section id="método-de-newton-raphson-de-2º-orden" class="level3" data-number="2.5.3">
<h3 data-number="2.5.3" class="anchored" data-anchor-id="método-de-newton-raphson-de-2º-orden"><span class="header-section-number">2.5.3</span> Método de Newton-Raphson de 2º Orden</h3>
<ul>
<li><p>Otra modificación al método de Newton-Raphson se deriva a partir de la utilización de un término más en el desarrollo por serie de Taylor de la función <span class="math inline">\(f(x)\)</span>.</p></li>
<li><p>Dada la existencia de las correspondientes derivadas, la fórmula de recurrencia resultante es:</p>
<p><span class="math display">\[
  p_n = p_{n-1} + \frac{f(p_{n-1})f'(p_{n-1})}{0.5 f(p_{n-1}) f''(p_{n-1}) - [f'(p_{n-1})]^2} \qquad n \geq 1
  \]</span></p></li>
<li><p>El método de Newton-Raphson de 2º orden llega más rápidamente a la raíz que el de primer orden, pero requiere de más cálculos y la desventaja de especificar también la derivada segunda.</p></li>
<li><p>Ejercicio propuesto: derivar la ecuación de recurrencia de este método de forma análoga a la derivación de la fórmula para el método de Newton-Raphson.</p></li>
</ul>


</section>
</section>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>El teorema de Bolzano es un caso particular del <strong>teorema de los valores intermedios</strong>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./01_intro.html" class="pagination-link  aria-label=" &lt;span="" básicos="" de="" análisis="" numérico&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Conceptos básicos de análisis numérico</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./03_sistemas_lineales.html" class="pagination-link" aria-label="<span class='chapter-number'>3</span>&nbsp; <span class='chapter-title'>Resolución de sistemas de ecuaciones lineales</span>">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Resolución de sistemas de ecuaciones lineales</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>