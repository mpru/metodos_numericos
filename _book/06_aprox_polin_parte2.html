<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.467">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Métodos Numéricos con Python - 7&nbsp; Aproximación polinomial - Parte 2: Derivación e integración</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06_aprox_polin_parte1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./06_aprox_polin_parte2.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Aproximación polinomial - Parte 2: Derivación e integración</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Métodos Numéricos con Python</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/mpru/metodos_numericos/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Métodos-Numéricos-con-Python.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Conceptos básicos de análisis numérico</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_ecuaciones.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Resolución de ecuaciones en una variable</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_sistemas_lineales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Resolución de sistemas de ecuaciones lineales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_sistemasnolineales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Resolución de sistemas de ecuaciones no lineales y optimización</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_autovalores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Valores y vectores propios</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_aprox_polin_parte1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Aproximación polinomial - Parte 1: interpolación</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_aprox_polin_parte2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Aproximación polinomial - Parte 2: Derivación e integración</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#diferenciación-numérica" id="toc-diferenciación-numérica" class="nav-link active" data-scroll-target="#diferenciación-numérica"><span class="header-section-number">7.1</span> Diferenciación numérica</a>
  <ul class="collapse">
  <li><a href="#fórmula-general" id="toc-fórmula-general" class="nav-link" data-scroll-target="#fórmula-general"><span class="header-section-number">7.1.1</span> Fórmula general</a></li>
  <li><a href="#fórmulas-de-tres-puntos" id="toc-fórmulas-de-tres-puntos" class="nav-link" data-scroll-target="#fórmulas-de-tres-puntos"><span class="header-section-number">7.1.2</span> Fórmulas de tres puntos</a></li>
  <li><a href="#inestabilidad-del-error-de-redondeo" id="toc-inestabilidad-del-error-de-redondeo" class="nav-link" data-scroll-target="#inestabilidad-del-error-de-redondeo"><span class="header-section-number">7.1.3</span> Inestabilidad del error de redondeo</a></li>
  </ul></li>
  <li><a href="#integración-numérica" id="toc-integración-numérica" class="nav-link" data-scroll-target="#integración-numérica"><span class="header-section-number">7.2</span> Integración numérica</a>
  <ul class="collapse">
  <li><a href="#fórmulas-comunes-y-cerradas-de-newton-cotes" id="toc-fórmulas-comunes-y-cerradas-de-newton-cotes" class="nav-link" data-scroll-target="#fórmulas-comunes-y-cerradas-de-newton-cotes"><span class="header-section-number">7.2.1</span> Fórmulas comunes y cerradas de Newton-Cotes</a></li>
  <li><a href="#fórmulas-compuestas-de-newton-cotes" id="toc-fórmulas-compuestas-de-newton-cotes" class="nav-link" data-scroll-target="#fórmulas-compuestas-de-newton-cotes"><span class="header-section-number">7.2.2</span> Fórmulas compuestas de Newton-Cotes</a></li>
  <li><a href="#métodos-de-cuadratura-adaptable-o-integración-adaptativa" id="toc-métodos-de-cuadratura-adaptable-o-integración-adaptativa" class="nav-link" data-scroll-target="#métodos-de-cuadratura-adaptable-o-integración-adaptativa"><span class="header-section-number">7.2.3</span> Métodos de cuadratura adaptable o integración adaptativa</a></li>
  <li><a href="#ejemplos-en-python" id="toc-ejemplos-en-python" class="nav-link" data-scroll-target="#ejemplos-en-python"><span class="header-section-number">7.2.4</span> Ejemplos en Python</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/mpru/metodos_numericos/edit/main/06_aprox_polin_parte2.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mpru/metodos_numericos/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mpru/metodos_numericos/blob/main/06_aprox_polin_parte2.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Aproximación polinomial - Parte 2: Derivación e integración</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="diferenciación-numérica" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="diferenciación-numérica"><span class="header-section-number">7.1</span> Diferenciación numérica</h2>
<ul>
<li><p>Nos enfrentamos al problema de aproximar el valor de la derivada de una función <span class="math inline">\(f(x)\)</span>.</p></li>
<li><p>Por definición, la derivada de la función <span class="math inline">\(f\)</span> en <span class="math inline">\(x_0\)</span> es:</p>
<p><span class="math display">\[
  f'(x_0) = \lim_{h\rightarrow0} \frac{f(x_0+h) - f(x_0)}{h}
  \]</span></p></li>
<li><p>Esta fórmula proporciona una forma obvia de generar una aproximación para <span class="math inline">\(f'(x_0)\)</span>: simplemente hay tomar <span class="math inline">\(h\)</span> pequeño y calcular:</p>
<p><span class="math display">\[
   \frac{f(x_0+h) - f(x_0)}{h}
  \]</span></p></li>
<li><p>Esta idea sencilla tiene el problema de enfrentarse a errores de redondeo (ya que sabemos que las divisiones por números pequeños son operaciones “delicadas”).</p></li>
<li><p>Sin embargo, es un buen punto de partida y coincide con la idea de derivar la expresión del polinomio de interpolación de Lagrange que pasa por los puntos <span class="math inline">\((x_0, f(x_0))\)</span> y <span class="math inline">\((x_1, f(x_1))\)</span>, considerando <span class="math inline">\(x_1 = x_0 + h\)</span>.</p></li>
</ul>
<!-- CREO QUE DEBERIA SACAR TODO ESTO EN EL 2022 -->
<ul>
<li><p>Recordemos la interpolación lineal de Lagrange:</p>
<p><span class="math display">\[
  \begin{aligned}
  P_1(x) &amp;= \frac{x - x_1}{x_0 - x_1} f(x_0) +\frac{x - x_0}{x_1 - x_0} f(x_1)  \\\\
  &amp;= \frac{x - x_0 -h}{-h} f(x_0) +\frac{x - x_0}{h} f(x_0+h)
  \end{aligned}
  \]</span></p></li>
<li><p>Ya estudiamos que disponemos de una fórmula para el error de truncamiento (o aproximación) al utilizar polinomios interpolantes. Cuando el polinomio es de grado <span class="math inline">\(n=1\)</span>, dicha fórmula queda como:</p>
<p><span class="math display">\[
  \frac{(x-x_0)(x-x_0-h)}{2} f''(\xi) \qquad \xi \text{ entre } x_0 \text{ y } x_1 = x_0+h
  \]</span></p></li>
<li><p>Entonces podemos escribir:</p>
<p><span class="math display">\[
  \begin{aligned}
  f(x) &amp;= P_1(x) + Error \\\\
  &amp;=  \frac{x - x_0 -h}{-h} f(x_0) +\frac{x - x_0}{h} f(x_0+h) + \frac{(x-x_0)(x-x_0-h)}{2} f''(\xi)
  \end{aligned}
  \]</span></p></li>
<li><p>Si derivamos tenemos:</p>
<p><span class="math display">\[
  \begin{aligned}
  f'(x) &amp;=
  -\frac{1}{h} f(x_0) +\frac{1}{h} f(x_0+h) + D_x \Big[ \frac{(x-x_0)(x-x_0-h)}{2} f''(\xi) \Big] \\\\
  &amp;= \frac{f(x_0+h) - f(x_0)}{h} + D_x \Big[ \frac{(x-x_0)(x-x_0-h)}{2} f''(\xi) \Big]
  \end{aligned}
  \]</span></p></li>
<li><p>Borrando el término relacionado con <span class="math inline">\(\xi\)</span> obtenemos la aproximación propuesta inicialmente:</p>
<p><span class="math display">\[
  f'(x) \approx \frac{f(x_0+h) - f(x_0)}{h}
  \]</span></p></li>
</ul>
<section id="fórmula-general" class="level3" data-number="7.1.1">
<h3 data-number="7.1.1" class="anchored" data-anchor-id="fórmula-general"><span class="header-section-number">7.1.1</span> Fórmula general</h3>
<ul>
<li>Esta idea se puede generalizar para obtener las <strong>fórmulas generales de la aproximación a la derivada</strong>:</li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: si <span class="math inline">\(x_0, x_1, ..., x_n\)</span> puntos distintos en algún intervalo <span class="math inline">\([a, b]\)</span> y <span class="math inline">\(f\)</span> tiene derivadas continuas hasta de orden <span class="math inline">\(n+1\)</span> en dicho intervalo, sabemos por la interpolación de Lagrange que:</p>
<p><span class="math display">\[
f(x) = \sum_{k=0}^{n} f(x_k) L_{k}(x) +  \frac{(x-x_0)...(x-x_n)}{(n+1)!} f^{(n+1)}(\xi)
\qquad L_{k}(x) = \prod^{n}_{\substack{i=0 \\ i \neq k}} \frac{x-x_i}{x_k-x_i}
\]</span></p>
<p>para algún <span class="math inline">\(\xi \in [a, b]\)</span>.</p>
<p>Al derivar esta ecuación obtenemos:</p>
<p><span class="math display">\[
f'(x) = \sum_{k=0}^{n} f(x_k) L'_{k}(x) + D_x \Big[ \frac{(x-x_0)...(x-x_n)}{(n+1)!} f^{(n+1)}(\xi) \Big]
\]</span></p>
<p>En general no se tiene conocimiento sobre <span class="math inline">\(D_x(f^{(n+1)}(\xi))\)</span> por lo cual no se puede acotar el error de truncamiento, pero si <span class="math inline">\(x\)</span> es uno de los nodos <span class="math inline">\(x_j\)</span>, entonces se demuestra que la fórmula queda igual a:</p>
<p><span class="math display">\[
f'(x_j) = \underbrace{\sum_{k=0}^{n} f(x_k) L'_{k}(x)}_{\text{Aproximación}} +
\underbrace{\frac{f^{(n+1)}(\xi)}{(n+1)!} \prod^{n}_{\substack{k=0 \\ k \neq j}} (x_j-x_k)}_{\text{Error}}
\]</span></p>
<p>y es llamada <strong>fórmula de <span class="math inline">\(n+1\)</span> puntos para aproximar <span class="math inline">\(f'(x_j)\)</span></strong>.</p>
<p>De esta forma, se puede acotar el error si a la derivada la calculamos en algún nodo del polinomio interpolante <span class="math inline">\(x_j\)</span>, pero nada impide utilizar la fórmula en otro caso, si estamos dispuestos a trabajar sin una cota para el error.</p>
</div>
<ul>
<li>En general, el uso de más puntos de evaluación en la ecuación anterior produce mayor precisión, pero el número de evaluaciones funcionales y el crecimiento del error de redondeo disuaden un poco de esto.</li>
<li>Las fórmulas más comunes son las de tres y cinco puntos de evaluación. Veremos sólo las de 3.</li>
</ul>
</section>
<section id="fórmulas-de-tres-puntos" class="level3" data-number="7.1.2">
<h3 data-number="7.1.2" class="anchored" data-anchor-id="fórmulas-de-tres-puntos"><span class="header-section-number">7.1.2</span> Fórmulas de tres puntos</h3>
<ul>
<li><p>Cuando se consideran tres puntos de evaluación, a partir del polinommio interpolante de grado de 2 de Lagrange, la fórmula anterior queda igual a:</p>
<p><span class="math display">\[
  \begin{aligned}
  f'(x_j) &amp;= f(x_0) \frac{2x_j-x_1-x_2}{(x_0-x_1)(x_0 - x_2)} \\\\
  &amp;+ f(x_1) \frac{2x_j-x_0-x_2}{(x_1-x_0)(x_1 - x_2)} \\\\
  &amp;+ f(x_2) \frac{2x_j-x_0-x_1}{(x_2-x_0)(x_2 - x_1)} \\\\
  &amp;+ \frac{f^{(3)}(\xi)}{6} \prod^{2}_{\substack{k=0 \\ k \neq j}} (x_j-x_k)
  \end{aligned}
  \]</span></p></li>
<li><p>Esto se simplifica mucho si los nodos están igualmente espaciados, de modo que <span class="math inline">\(x_1 = x_0 + h\)</span> y <span class="math inline">\(x_2 = x_0 + 2h\)</span>.</p></li>
<li><p>Implementando dichos reemplazos y aplicando cambios de variables, a partir de lo anterior se deducen dos fórmulas de tres puntos para aproximar <span class="math inline">\(f'(x_0)\)</span>:</p></li>
</ul>
<p><strong>Fórmula del extremo de tres puntos</strong>:</p>
<p><span class="math display">\[
f'(x_0) = \frac{-3 f(x_0) + 4 f(x_0+h) - f(x_0 + 2h)}{2h} + \frac{h^2}{3} f^{(3)}(\xi), \qquad \xi \text{ entre } x_0\ \text{ y }\, x_0+2h
\]</span></p>
<p><strong>Fórmula del punto medio de tres puntos</strong>:</p>
<p><span class="math display">\[
f'(x_0) = \frac{f(x_0+h) - f(x_0 -h)}{2h} - \frac{h^2}{6} f^{(3)}(\xi), \qquad \xi \text{ entre } x_0-h\ \text{ y }\, x_0+h
\]</span></p>
<ul>
<li>La fórmula del extremo se usa para aproximar la derivada cuando <span class="math inline">\(x_0\)</span> es uno de los extremos del intervalo (<span class="math inline">\(h\)</span> puede ser negativo), mientras que la otra cuando <span class="math inline">\(x_0\)</span> es el punto medio.</li>
<li>La fórmula del punto medio presenta un error que es la mitad del de la fórmula del extremo y además requiere que <span class="math inline">\(f\)</span> se evalúe solamente en dos puntos.</li>
</ul>
<!-- AGREGAR EJEMPLO 2022 -->
</section>
<section id="inestabilidad-del-error-de-redondeo" class="level3" data-number="7.1.3">
<h3 data-number="7.1.3" class="anchored" data-anchor-id="inestabilidad-del-error-de-redondeo"><span class="header-section-number">7.1.3</span> Inestabilidad del error de redondeo</h3>
<ul>
<li>Para reducir el error de truncamiento necesitamos reducir <span class="math inline">\(h\)</span>.</li>
<li>Pero se demuestra que conforme <span class="math inline">\(h\)</span> se reduce, el error de redondeo crece.</li>
<li>En la práctica, entonces, casi nunca es ventajoso dejar que <span class="math inline">\(h\)</span> sea demasiado pequeña, porque en este caso, el error de redondeo dominará los cálculos.</li>
<li>La diferenciación numérica es <strong>inestable</strong> ya que los valores de <span class="math inline">\(h\)</span> necesarios para reducir el error de truncamiento causan que el error de redonde crezca.</li>
</ul>
</section>
</section>
<section id="integración-numérica" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="integración-numérica"><span class="header-section-number">7.2</span> Integración numérica</h2>
<ul>
<li>A menudo surge la necesidad de evaluar la integral definida de una función que no tiene una antiderivada o cuya antiderivada no es fácil de obtener (por ejemplo, para calcular probabilidades bajo la distribución normal).</li>
<li>En estos casos se puede aproximar el valor de la integral mediante los <strong>métodos de cuadratura</strong>.</li>
</ul>
<div class="alert alert-success">
<p><strong>Definición</strong>: los <strong>métodos de cuadratura</strong> se utilizan para aproximar la integral definida <span class="math inline">\(\int_a^b f(x) dx\)</span> mediante una suma <span class="math inline">\(\sum_{k=0}^n a_k f(x_k)\)</span>.</p>
</div>
<ul>
<li><p>La idea básica es seleccionar un conjunto de nodos <span class="math inline">\(x_0, x_1, ..., x_n\)</span> en el intervalo <span class="math inline">\([a, b]\)</span> e integrar el polinomio interpolante de Lagrange que pase por dichos nodos.</p></li>
<li><p>Recordemos la expresión del polinomio de Lagrange junto con su término de error:</p></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
f(x)  &amp;= P_n(x) + Error \\\\
&amp;= \sum_{k=0}^{n} f(x_k) L_{k} +  \frac{f^{(n+1)}(\xi)}{(n+1)!} \prod_{k=0}^n (x-x_k) \qquad \xi \in (a, b)
\qquad L_k = \prod^{n}_{\substack{i=0 \\ i \neq k}} \frac{x-x_i}{x_k-x_i}
\end{aligned}
\]</span></p>
<ul>
<li>Integrando nos queda:</li>
</ul>
<p><span class="math display">\[
\int_a^b f(x) dx
= \underbrace{\sum_{k=0}^{n} \Big( \overbrace{\int_a^b L_{k} dx}^{a_k}\Big)f(x_k) }_{\text{Fórmula de cuadratura}}
+ \underbrace{\frac{1}{(n+1)!}  \int_a^b f^{(n+1)}(\xi) \prod_{k=0}^n (x-x_k)  dx}_{\text{Error de aproximación}}
\]</span></p>
<ul>
<li><span class="math inline">\(\int_a^b L_{k} dx\)</span> es fácil de hallar porque se trata de un polinomio de grado <span class="math inline">\(n\)</span> que depende de los nodos observados <span class="math inline">\(x_i\)</span>.</li>
<li>La fórmula anterior es general para cualquier cantidad de nodos <span class="math inline">\(n\)</span>, sean equidistantes o no.</li>
<li>Cuando se trabaja con nodos igualmente espaciados, esta expresión da lugar a conjunto de fórmulas conocidas como <strong>Fórmulas de integración de Newton-Cotes</strong>.</li>
</ul>
<section id="fórmulas-comunes-y-cerradas-de-newton-cotes" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="fórmulas-comunes-y-cerradas-de-newton-cotes"><span class="header-section-number">7.2.1</span> Fórmulas comunes y cerradas de Newton-Cotes</h3>
<ul>
<li><p>La denominación de “cerradas” hace referencia a que los extremos del intervalo <span class="math inline">\([a, b]\)</span> se incluyen como nodos (están las fórmulas “abiertas” pero no las veremos).</p></li>
<li><p>La denominación de “comunes” distingue a estas fórmulas de las “compuestas” que veremos en la próxima sección.</p></li>
<li><p>Vamos a ver tres fórmulas, que resultan de simplificar la expresión anterior para los siguientes casos particulares:</p>
<ol type="1">
<li>Cuando se consideran sólo dos nodos en el intervalo <span class="math inline">\([a, b]\)</span> (<em>regla trapezoidal</em>).</li>
<li>Cuando se consideran tres nodos equidistantes en el intervalo <span class="math inline">\([a, b]\)</span> (<em>regla de Simpson</em>).</li>
<li>Cuando se consideran cuatro nodos equidistantes en el intervalo <span class="math inline">\([a, b]\)</span> (<em>regla de tres octavos de Simpson</em>).</li>
</ol></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Plots/U6/interp1.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>El área sombreada es el resultado de la aproximación.</figcaption>
</figure>
</div>
</div>
</div>
<section id="regla-trapezoidal" class="level4" data-number="7.2.1.1">
<h4 data-number="7.2.1.1" class="anchored" data-anchor-id="regla-trapezoidal"><span class="header-section-number">7.2.1.1</span> Regla trapezoidal</h4>
<ul>
<li>Se consideran sólo dos nodos en el intervalo <span class="math inline">\([a, b]\)</span>.</li>
<li>En este caso se tiene <span class="math inline">\(a = x_0\)</span> y <span class="math inline">\(b=x_1\)</span> y llamamos <span class="math inline">\(h = x_1 - x_0\)</span>.</li>
<li><span class="math inline">\(P_n(x)\)</span> es la recta que pasa por los puntos <span class="math inline">\((x_0, f(x_0))\)</span> y <span class="math inline">\((x_1, f(x_1))\)</span>.</li>
<li>La fórmula es:</li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_1} f(x) dx
= \frac{h}{2} [f(x_0) + f(x_1)] -  \underbrace{\frac{h^3}{12} f''(\xi)}_{\text{Error}}
\]</span></p>
<ul>
<li>Recibe el nombre de regla trapezoidal porque cuando <span class="math inline">\(f\)</span> es una función con valores positivos, <span class="math inline">\(\int_a^b f(x) dx\)</span> se aproxima mediante el área de un trapecio. <!-- - El término de error depende de $f''$, por lo que la regla da el resultado exacto cuando se aplica a cualquier función cuya derivada segunda es idénticamente cero --></li>
</ul>
</section>
<section id="regla-de-simpson" class="level4" data-number="7.2.1.2">
<h4 data-number="7.2.1.2" class="anchored" data-anchor-id="regla-de-simpson"><span class="header-section-number">7.2.1.2</span> Regla de Simpson</h4>
<ul>
<li>Resulta de la integración sobre <span class="math inline">\([a, b]\)</span> del segundo polinomio de Lagrange con nodos igualmente espaciados <span class="math inline">\(x_0 = a\)</span>, <span class="math inline">\(x_1 = x_0 +h\)</span> y <span class="math inline">\(x2 = x_0+2h=b\)</span>, es decir: <span class="math inline">\(h=(b-a)/2\)</span>.</li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_2} f(x) dx
= \frac{h}{3} [f(x_0) + 4f(x_1) + f(x_2)] -  \underbrace{\frac{h^5}{90} f^{(4)}(\xi)}_{\text{Error}}
\]</span></p>
<ul>
<li>El término de error queda en función de la cuarta derivada de <span class="math inline">\(f\)</span>, por lo que da resultados exactos cuando <span class="math inline">\(f(x)\)</span> es un polinomio de grado 3 o menos.</li>
</ul>
</section>
<section id="regla-de-tres-octavos-simpson" class="level4" data-number="7.2.1.3">
<h4 data-number="7.2.1.3" class="anchored" data-anchor-id="regla-de-tres-octavos-simpson"><span class="header-section-number">7.2.1.3</span> Regla de tres octavos Simpson</h4>
<ul>
<li>Resulta de considerar cuatro nodos igualmente espaciados <span class="math inline">\(x_0 = a\)</span>, <span class="math inline">\(x_1 = x_0 +h\)</span>, <span class="math inline">\(x2 = x_0+2h\)</span> y <span class="math inline">\(x_3=x_0+3h=b\)</span> e integrar el polinomio de Lagrange de grado 3 que pasa por ellos</li>
<li>En este caso: <span class="math inline">\(h=(b-a)/3\)</span>.</li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_3} f(x) dx
= \frac{3h}{8} [f(x_0) + 3f(x_1)+ 3f(x_2) + f(x_3)] -  \underbrace{\frac{3h^5}{80} f^{(4)}(\xi)}_{\text{Error}}
\]</span></p>
</section>
</section>
<section id="fórmulas-compuestas-de-newton-cotes" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="fórmulas-compuestas-de-newton-cotes"><span class="header-section-number">7.2.2</span> Fórmulas compuestas de Newton-Cotes</h3>
<ul>
<li>En general, el uso de las fórmula de Newton-Cotes es inapropiado sobre largos intervalos de integración, porque se pueden dar situaciones como estas:</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U6/interp2.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<ul>
<li><p>Se podrían usar fórmulas de grado superior a las vistas, dividiendo al intervalo en más de 4 puntos e integrando el polinomio interpolante que pase por ellos, pero esto implica la necesidad de obtener coeficientes de cálculo cada vez más tedioso.</p></li>
<li><p>Como alternativa se presentan las <strong>fórmulas de integración compuestas</strong>, que consisten en emplear las fórmulas de bajo orden de la sección anterior sucesivamente a lo largo del intervalo de interés.</p></li>
<li><p><strong>Ejemplo</strong>. Se tienen los siguientes valores tabulados de <span class="math inline">\(f(x)\)</span> y se desea hallar su integral entre 0 y 6. La curva roja es la verdadera función <span class="math inline">\(f(x)\)</span> que originó la tabla, la cual suponemos desconocida o difícil de integrar. En este caso tenemos <span class="math inline">\(h=0.5\)</span>.</p></li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(x\)</span></th>
<th style="text-align: center;"><span class="math inline">\(f(x)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">2.00</td>
</tr>
<tr class="even">
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">3.13</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1.0</td>
<td style="text-align: center;">2.14</td>
</tr>
<tr class="even">
<td style="text-align: center;">1.5</td>
<td style="text-align: center;">1.14</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2.0</td>
<td style="text-align: center;">1.78</td>
</tr>
<tr class="even">
<td style="text-align: center;">2.5</td>
<td style="text-align: center;">2.64</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3.0</td>
<td style="text-align: center;">2.25</td>
</tr>
<tr class="even">
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">1.53</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4.0</td>
<td style="text-align: center;">1.75</td>
</tr>
<tr class="even">
<td style="text-align: center;">4.5</td>
<td style="text-align: center;">2.34</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5.0</td>
<td style="text-align: center;">2.24</td>
</tr>
<tr class="even">
<td style="text-align: center;">5.5</td>
<td style="text-align: center;">1.77</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6.0</td>
<td style="text-align: center;">1.78</td>
</tr>
</tbody>
</table>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U6/interp4.png" class="img-fluid" style="width:60.0%"></p>
</div>
</div>
<section id="regla-trapecial-compuesta" class="level4" data-number="7.2.2.1">
<h4 data-number="7.2.2.1" class="anchored" data-anchor-id="regla-trapecial-compuesta"><span class="header-section-number">7.2.2.1</span> Regla trapecial compuesta</h4>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U6/interp3.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<ul>
<li><p>Se aplica la regla trapecial entre cada par consecutivo de nodos <span class="math inline">\(x_i\)</span> y se suman los resultados.</p></li>
<li><p>En el ejemplo, para el primer intervalo entre <span class="math inline">\(x_0\)</span> y <span class="math inline">\(x_1\)</span>:</p></li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_1} f(x) dx
\approx \frac{h}{2} [f(x_0) + f(x_1)]
\implies
\int_{0}^{0.5} f(x)dx \approx  \frac{0.5}{2} (3.13 + 2) = 1.2825 = A_1
\]</span></p>
<ul>
<li>Geométricamente, esto equivale al área <span class="math inline">\(A_1\)</span> del trapecio formado por la recta de interpolación y el eje de las abscisas, entre <span class="math inline">\(x_0\)</span> y <span class="math inline">\(x_1\)</span>.</li>
<li>De manera semejante, se puede emplear la interpolación lineal para obtener una aproximación de la integral entre <span class="math inline">\(x_1\)</span> y <span class="math inline">\(x_2\)</span>:</li>
</ul>
<p><span class="math display">\[
\int_{x_1}^{x_2} f(x)dx \approx \frac{h}{2} (f(x_1) + f(x_2)) = 1.3175 = A_2
\]</span></p>
<ul>
<li>Y sucesivamente para todos los intervalos entre <span class="math inline">\(x_{i-1}\)</span> y <span class="math inline">\(x_i\)</span>:</li>
</ul>
<p><span class="math display">\[
\int_{x_{i-1}}^{x_i} f(x)dx \approx \frac{h}{2} (f(x_{i-1}) + f(x_i)) = A_i \quad i = 1, \cdots, n
\]</span></p>
<ul>
<li>La suma de las áreas de los trapecios <span class="math inline">\(A_i\)</span> resulta ser la aproximación para la integral entre <span class="math inline">\(x_0\)</span> y <span class="math inline">\(x_n\)</span>:</li>
</ul>
<p><span class="math display">\[
\int_{x_{0}}^{x_n} f(x)dx \approx \sum_{i=1}^n A_i = \sum_{i=1}^n \frac{h}{2} (f(x_{i-1}) + f(x_i)) = \frac{h}{2} \Big[ f(a)  + 2 \sum_{i = 1}^{n-1} f(x_i)  + f(b)\Big]
\]</span></p>
<ul>
<li>El error está dado por: <span class="math inline">\(-\frac{b-a}{12}h^2f''(\mu)\)</span>, con <span class="math inline">\(\mu \in (a, b)\)</span>.</li>
<li>Cuanto menor sea el ancho de los intervalos <span class="math inline">\(h\)</span> y más se acerque <span class="math inline">\(f(x)\)</span> a una recta dentro de dichos intervalos, mejor será la aproximación así obtenida.</li>
<li>En el ejemplo el resultado es <span class="math inline">\(\int_0^6 f(x)dx \approx 12.3000\)</span>.</li>
<li>El valor exacto es: <span class="math inline">\(\int_0^{6}f(x)dx = 12.2935\)</span>, con lo cual el error relativo de la aproximación con la fórmula trapecial fue: <span class="math inline">\(0.05\%\)</span>.</li>
</ul>
<!--
https://www.integral-calculator.com/
2 + exp((1-x)/4) * sin(4 * x)

http://www.wolframalpha.com/widgets/view.jsp?id=8ab70731b1553f17c11a3bbc87e0b605
2 + exp((1-x)/4) * sin(4 * x)dx

-->
</section>
<section id="regla-de-simpson-compuesta" class="level4" data-number="7.2.2.2">
<h4 data-number="7.2.2.2" class="anchored" data-anchor-id="regla-de-simpson-compuesta"><span class="header-section-number">7.2.2.2</span> Regla de Simpson compuesta</h4>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U6/interp5.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<ul>
<li><p>Se aplica la regla de Simpson tomando de a tres nodos <span class="math inline">\(x_i\)</span> y se suman los resultados. Es decir, se usan integrales de polinomios de grado 2.</p></li>
<li><p>Requiere que la cantidad <span class="math inline">\(n+1\)</span> de nodos sea impar.</p></li>
<li><p>En el ejemplo y para el primer tramo, obtenemos el área encerrada entre el eje de las abscisas, <span class="math inline">\(x_0\)</span> y <span class="math inline">\(x_2\)</span> y el polinomio integrador que pasa por <span class="math inline">\((x_0, f(x_0))\)</span>, <span class="math inline">\((x_1, f(x_1))\)</span> y <span class="math inline">\((x_2, f(x_2))\)</span>:</p></li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_2} f(x)dx \approx  \frac{h}{3} (f(x_0) + 4f(x_1) + f(x_2)) = 2.7766 = A_1
\]</span></p>
<ul>
<li>De manera semejante, se puede emplear la interpolación cuadrática para obtener una aproximación de la integral entre <span class="math inline">\(x_2\)</span> y <span class="math inline">\(x_4\)</span>:</li>
</ul>
<p><span class="math display">\[
\int_{x_2}^{x_4} f(x)dx \approx  \frac{h}{3} (f(x_2) + 4f(x_3) + f(x_4)) = 1.4133= A_2
\]</span></p>
<ul>
<li>Y sucesivamente para todos los tramos:</li>
</ul>
<p><span class="math display">\[
\int_{x_{i-1}}^{x_{i+1}} f(x)dx \approx  \frac{h}{3} (f(x_{i-1}) + 4f(x_i) + f(x_{i+1}))  \quad i = 1, 3, 5, \cdots, n-1
\]</span></p>
<ul>
<li>La suma de estas áreas resulta ser la aproximación para la integral entre <span class="math inline">\(x_0\)</span> y <span class="math inline">\(x_n\)</span>:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{x_{0}}^{x_n} f(x)dx &amp;\approx  
\sum\limits_{\substack{i = 1\\ i~impar}}^{n-1} \frac{h}{3} \Big[ f(x_{i-1}) + 4f(x_i) + f(x_{i+1})\Big] \\\\
&amp;= \frac{h}{3} \Big[ f(a)  + 2 \underbrace{\sum_{i=1}^{n/2-1} f(x_{2i})}_{\substack{\text{suma con nodos}\\ \text{de subíndice par} \\ \text{entre 2 y n-2}}} + 4 \underbrace{\sum_{i = 1}^{n/2} f(x_{2i-1})}_{\substack{\text{suma con nodos}\\ \text{de subíndice impar} \\ \text{entre 1 y n-1}}}  + f(b) \Big]
\end{aligned}
\]</span></p>
<ul>
<li>El error está dado por: <span class="math inline">\(-\frac{b-a}{180}h^4f^{(4)}(\mu)\)</span>, con <span class="math inline">\(\mu \in (a, b)\)</span>.</li>
<li>En el ejemplo el resultado es <span class="math inline">\(12.3833\)</span>.</li>
<li>El valor exacto es: <span class="math inline">\(\int_0^{6}f(x)dx = 12.2935\)</span>, con lo cual el error relativo de la aproximación con la fórmula compuesta de Simpson fue: <span class="math inline">\(7.3\%\)</span>.</li>
</ul>
</section>
<section id="regla-de-tres-octavos-de-simpson-compuesta" class="level4" data-number="7.2.2.3">
<h4 data-number="7.2.2.3" class="anchored" data-anchor-id="regla-de-tres-octavos-de-simpson-compuesta"><span class="header-section-number">7.2.2.3</span> Regla de tres octavos de Simpson compuesta</h4>
<div class="cell">
<div class="cell-output-display">
<p><img src="Plots/U6/interp6.png" class="img-fluid" style="width:100.0%"></p>
</div>
</div>
<ul>
<li>Se aplica la regla de Simpson tomando de a cuatro nodos <span class="math inline">\(x_i\)</span> y se suman los resultados. Es decir, se usan integrales de polinomios de grado 3.</li>
<li>Es necesario que <span class="math inline">\(n\)</span> sea múltiplo de 3, siendo <span class="math inline">\(n\)</span> la cantidad de nodos menos uno (o bien, la cantidad de intervalos equiespaciados entre nodos).</li>
<li>En el primer tramo con los 4 primeros valores de <span class="math inline">\(x\)</span>, se obtiene:</li>
</ul>
<p><span class="math display">\[
\int_{x_0}^{x_3} f(x)dx \approx \frac{3h}{8} \Big( f(x_0) + 3f(x_1) + 3f(x_2)+f(x_3) \Big) = 3.5531 = A_1
\]</span></p>
<ul>
<li>Geométricamente, esto equivale al área encerrada entre el eje de las abscisas, <span class="math inline">\(x_0\)</span> y <span class="math inline">\(x_3\)</span> y el polinomio integrador que pasa por <span class="math inline">\((x_0, f(x_0))\)</span>, <span class="math inline">\((x_1, f(x_1))\)</span>, <span class="math inline">\((x_2, f(x_2))\)</span> y <span class="math inline">\((x_3, f(x_3))\)</span>:</li>
<li>De manera semejante, se puede emplear la interpolación cúbica para obtener una aproximación de la integral entre <span class="math inline">\(x_3\)</span> y <span class="math inline">\(x_6\)</span>:</li>
</ul>
<p><span class="math display">\[
\int_{x_3}^{x_6} f(x)dx \approx \frac{3h}{8} \Big(f(x_3) + 3f(x_4) + 3f(x_5) + f(x_6)\Big) = 3.1219 = A_2
\]</span></p>
<ul>
<li>Y sucesivamente para todos los intervalos:</li>
</ul>
<p><span class="math display">\[
\int_{x_{i}}^{x_{i+3}} f(x)dx \approx  \frac{3h}{8}  \Big(f(x_{i}) + 3f(x_{i+1}) + 3f(x_{i+2}) + f(x_{i+3}) \Big) \quad i = 0, 3, 6, \cdots, n-3
\]</span></p>
<ul>
<li>De modo que la suma de estas áreas resulta ser la aproximación para la integral entre <span class="math inline">\(x_0\)</span> y <span class="math inline">\(x_n\)</span>:</li>
</ul>
<p><span class="math display">\[
\int_{x_{0}}^{x_n} f(x)dx  \approx \frac{3h}{8}  \sum_{i=1}^{n/3} \Big(f(x_{3i-3}) + 3f(x_{3i-2}) + 3f(x_{3i-1}) + f(x_{3i}) \Big)
\]</span></p>
<ul>
<li>El error está dado por: <span class="math inline">\(-\frac{b-a}{80}h^4f^{(4)}(\mu)\)</span>, con <span class="math inline">\(\mu \in (a, b)\)</span>.</li>
<li>En el ejemplo el resultado es <span class="math inline">\(12.4088\)</span>.</li>
<li>El valor exacto es: <span class="math inline">\(\int_0^{6}f(x)dx = 12.2935\)</span>, con lo cual el error relativo de la aproximación con la fórmula compuesta de tres octavos de Simpson fue: <span class="math inline">\(9.4\%\)</span>.</li>
</ul>
</section>
<section id="estabilidad-del-error-de-redondeo" class="level4" data-number="7.2.2.4">
<h4 data-number="7.2.2.4" class="anchored" data-anchor-id="estabilidad-del-error-de-redondeo"><span class="header-section-number">7.2.2.4</span> Estabilidad del error de redondeo</h4>
<ul>
<li>Una propiedad importante compartida por todas las técnicas de integración compuesta es su estabilidad respecto al error de redondeo.</li>
<li>Es decir, sorprendentemente, el error de redondeo no depende del número de cálculos realizados al aplicar estas fórmulas (demostración en página 156).</li>
<li>Esto no es verdad para los procedimientos de diferenciación numérica.</li>
</ul>
</section>
</section>
<section id="métodos-de-cuadratura-adaptable-o-integración-adaptativa" class="level3" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="métodos-de-cuadratura-adaptable-o-integración-adaptativa"><span class="header-section-number">7.2.3</span> Métodos de cuadratura adaptable o integración adaptativa</h3>
<ul>
<li>Las reglas compuestas de cuadratura vistas necesitan nodos equiespaciados.</li>
<li>Generalmente, se usa un incremento pequeño <span class="math inline">\(h\)</span> de manera uniforme en todo el intervalo de integración para garantizar una precisión global.</li>
<li>Este proceso no tienen en cuenta el hecho de que en algunas porciones de la curva puedan aparecer oscilaciones más pronunciadas que en otras y, en consecuencia, requieran incrementos más pequeños para conseguir la misma precisión.</li>
<li>Sería interesante disponer de un método que vaya ajustando el incremento de manera que sea menor en aquellas porciones de la curva en la que aparezcan oscilaciones más pronunciadas.</li>
<li>Los métodos de cuadratura adaptable o integración adaptativa se encargan de implementar esto, pero no los estudiaremos.</li>
</ul>
</section>
<section id="ejemplos-en-python" class="level3" data-number="7.2.4">
<h3 data-number="7.2.4" class="anchored" data-anchor-id="ejemplos-en-python"><span class="header-section-number">7.2.4</span> Ejemplos en Python</h3>
<ul>
<li>Importamos módulos necesarios:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> unidad6_funciones <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Vamos a usar la función <code>newton_cotes()</code> para aplicar estas tres fórmulas de integración:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>fx <span class="op">=</span> np.array([<span class="dv">2</span>, <span class="fl">3.13</span>, <span class="fl">2.14</span>, <span class="fl">1.14</span>, <span class="fl">1.78</span>, <span class="fl">2.64</span>, <span class="fl">2.25</span>, <span class="fl">1.53</span>, <span class="fl">1.75</span>, <span class="fl">2.34</span>, <span class="fl">2.24</span>, <span class="fl">1.77</span>, <span class="fl">1.78</span>])</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Fórmula trapecial</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>newton_cotes(fx, h <span class="op">=</span> <span class="fl">0.5</span>, formula <span class="op">=</span> <span class="st">"trapecio"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>12.299999999999999</code></pre>
</div>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fórmula de Simpson de 1/3</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>newton_cotes(fx, h <span class="op">=</span> <span class="fl">0.5</span>, formula <span class="op">=</span> <span class="st">"simpson"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>12.383333333333333</code></pre>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fórmula de Simpson de 3/8</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>newton_cotes(fx, h <span class="op">=</span> <span class="fl">0.5</span>, formula <span class="op">=</span> <span class="st">"tres_octavos"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>12.408750000000001</code></pre>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Proveyendo distintos valores de fx se pueden obtener otras aproximaciones </span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Por ejemplo, fórmula del trapecio común entre x=0 y x=6 (ojo, el intervalo es</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># muy ancho para esto)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>newton_cotes(fx <span class="op">=</span> np.array([<span class="dv">2</span>, <span class="fl">1.78</span>]), h <span class="op">=</span> <span class="dv">6</span>, formula <span class="op">=</span> <span class="st">"trapecio"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>11.34</code></pre>
</div>
</div>
<!-- - La función fue agregada al archivo de funciones en el aula virtual, pero tiene implementado los casos para la fórmula trapecial y la de Simpson de 1/3, queda propuesto como ejercicio completar su definición con la fórmula de Simpson de 3/8. -->


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./06_aprox_polin_parte1.html" class="pagination-link  aria-label=" &lt;span="" polinomial="" -="" parte="" 1:="" interpolación&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Aproximación polinomial - Parte 1: interpolación</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>